/*
 * Woleet API
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation. 
 *
 * OpenAPI spec version: 1.5.3
 * Contact: contact@woleet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.woleet.api.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.woleet.api.client.model.ReceiptAnchorsNode;
import io.woleet.api.client.model.ReceiptHeader;
import io.woleet.api.client.model.ReceiptProofNode;
import io.woleet.api.client.model.ReceiptSignature;
import io.woleet.api.client.model.ReceiptTarget;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * A Chainpoint 1.x or 2.x proof receipt
 */
@ApiModel(description = "A Chainpoint 1.x or 2.x proof receipt")

public class Receipt {
  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type = "ChainpointSHA256v2";

  public static final String SERIALIZED_NAME_TARGET_HASH = "targetHash";
  @SerializedName(SERIALIZED_NAME_TARGET_HASH)
  private String targetHash;

  public static final String SERIALIZED_NAME_MERKLE_ROOT = "merkleRoot";
  @SerializedName(SERIALIZED_NAME_MERKLE_ROOT)
  private String merkleRoot;

  public static final String SERIALIZED_NAME_PROOF = "proof";
  @SerializedName(SERIALIZED_NAME_PROOF)
  private List<ReceiptProofNode> proof = null;

  public static final String SERIALIZED_NAME_ANCHORS = "anchors";
  @SerializedName(SERIALIZED_NAME_ANCHORS)
  private List<ReceiptAnchorsNode> anchors = null;

  public static final String SERIALIZED_NAME_SIGNATURE = "signature";
  @SerializedName(SERIALIZED_NAME_SIGNATURE)
  private ReceiptSignature signature = null;

  public static final String SERIALIZED_NAME_HEADER = "header";
  @SerializedName(SERIALIZED_NAME_HEADER)
  private ReceiptHeader header = null;

  public static final String SERIALIZED_NAME_TARGET = "target";
  @SerializedName(SERIALIZED_NAME_TARGET)
  private ReceiptTarget target = null;

  public Receipt type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Chainpoint 2.x only. Type of Chainpoint 2.x receipt.
   * @return type
  **/
  @ApiModelProperty(value = "Chainpoint 2.x only. Type of Chainpoint 2.x receipt.")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public Receipt targetHash(String targetHash) {
    this.targetHash = targetHash;
    return this;
  }

   /**
   * Chainpoint 2.x only. SHA256 hash of the proven data or signature.
   * @return targetHash
  **/
  @ApiModelProperty(value = "Chainpoint 2.x only. SHA256 hash of the proven data or signature.")
  public String getTargetHash() {
    return targetHash;
  }

  public void setTargetHash(String targetHash) {
    this.targetHash = targetHash;
  }

  public Receipt merkleRoot(String merkleRoot) {
    this.merkleRoot = merkleRoot;
    return this;
  }

   /**
   * Chainpoint 2.x only. Root of the Merkle tree.
   * @return merkleRoot
  **/
  @ApiModelProperty(value = "Chainpoint 2.x only. Root of the Merkle tree.")
  public String getMerkleRoot() {
    return merkleRoot;
  }

  public void setMerkleRoot(String merkleRoot) {
    this.merkleRoot = merkleRoot;
  }

  public Receipt proof(List<ReceiptProofNode> proof) {
    this.proof = proof;
    return this;
  }

  public Receipt addProofItem(ReceiptProofNode proofItem) {
    if (this.proof == null) {
      this.proof = new ArrayList<ReceiptProofNode>();
    }
    this.proof.add(proofItem);
    return this;
  }

   /**
   * Chainpoint 2.x only. Merkle proof: path from &#x60;targetHash&#x60; to &#x60;merkleRoot&#x60; in the Merkle tree. 
   * @return proof
  **/
  @ApiModelProperty(value = "Chainpoint 2.x only. Merkle proof: path from `targetHash` to `merkleRoot` in the Merkle tree. ")
  public List<ReceiptProofNode> getProof() {
    return proof;
  }

  public void setProof(List<ReceiptProofNode> proof) {
    this.proof = proof;
  }

  public Receipt anchors(List<ReceiptAnchorsNode> anchors) {
    this.anchors = anchors;
    return this;
  }

  public Receipt addAnchorsItem(ReceiptAnchorsNode anchorsItem) {
    if (this.anchors == null) {
      this.anchors = new ArrayList<ReceiptAnchorsNode>();
    }
    this.anchors.add(anchorsItem);
    return this;
  }

   /**
   * Chainpoint 2.x only. List of sources where the root of the Merkle proof is anchored.
   * @return anchors
  **/
  @ApiModelProperty(value = "Chainpoint 2.x only. List of sources where the root of the Merkle proof is anchored.")
  public List<ReceiptAnchorsNode> getAnchors() {
    return anchors;
  }

  public void setAnchors(List<ReceiptAnchorsNode> anchors) {
    this.anchors = anchors;
  }

  public Receipt signature(ReceiptSignature signature) {
    this.signature = signature;
    return this;
  }

   /**
   * Get signature
   * @return signature
  **/
  @ApiModelProperty(value = "")
  public ReceiptSignature getSignature() {
    return signature;
  }

  public void setSignature(ReceiptSignature signature) {
    this.signature = signature;
  }

  public Receipt header(ReceiptHeader header) {
    this.header = header;
    return this;
  }

   /**
   * Get header
   * @return header
  **/
  @ApiModelProperty(value = "")
  public ReceiptHeader getHeader() {
    return header;
  }

  public void setHeader(ReceiptHeader header) {
    this.header = header;
  }

  public Receipt target(ReceiptTarget target) {
    this.target = target;
    return this;
  }

   /**
   * Get target
   * @return target
  **/
  @ApiModelProperty(value = "")
  public ReceiptTarget getTarget() {
    return target;
  }

  public void setTarget(ReceiptTarget target) {
    this.target = target;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Receipt receipt = (Receipt) o;
    return Objects.equals(this.type, receipt.type) &&
        Objects.equals(this.targetHash, receipt.targetHash) &&
        Objects.equals(this.merkleRoot, receipt.merkleRoot) &&
        Objects.equals(this.proof, receipt.proof) &&
        Objects.equals(this.anchors, receipt.anchors) &&
        Objects.equals(this.signature, receipt.signature) &&
        Objects.equals(this.header, receipt.header) &&
        Objects.equals(this.target, receipt.target);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, targetHash, merkleRoot, proof, anchors, signature, header, target);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Receipt {\n");
    
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    targetHash: ").append(toIndentedString(targetHash)).append("\n");
    sb.append("    merkleRoot: ").append(toIndentedString(merkleRoot)).append("\n");
    sb.append("    proof: ").append(toIndentedString(proof)).append("\n");
    sb.append("    anchors: ").append(toIndentedString(anchors)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("    header: ").append(toIndentedString(header)).append("\n");
    sb.append("    target: ").append(toIndentedString(target)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

