/*
 * Woleet API
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation. 
 *
 * The version of the OpenAPI document: 1.10.0
 * Contact: contact@woleet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.woleet.api.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.woleet.api.client.model.ReceiptAnchorsNode;
import io.woleet.api.client.model.ReceiptProofNode;
import io.woleet.api.client.model.ReceiptSignature;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * A proof receipt:&lt;br&gt; - the proof of timestamp is provided as a Chainpoint 2.x proof receipt.&lt;br&gt; - the proof of signature (if applicable) is provided in the &#x60;signature&#x60; property.&lt;br&gt; If the proof receipt is partial (ie. does not contain the proof of timestamp) Chainpoint 2.x fields are not provided. 
 */
@ApiModel(description = "A proof receipt:<br> - the proof of timestamp is provided as a Chainpoint 2.x proof receipt.<br> - the proof of signature (if applicable) is provided in the `signature` property.<br> If the proof receipt is partial (ie. does not contain the proof of timestamp) Chainpoint 2.x fields are not provided. ")

public class Receipt {
  public static final String SERIALIZED_NAME_TARGET_HASH = "targetHash";
  @SerializedName(SERIALIZED_NAME_TARGET_HASH)
  private String targetHash;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_MERKLE_ROOT = "merkleRoot";
  @SerializedName(SERIALIZED_NAME_MERKLE_ROOT)
  private String merkleRoot;

  public static final String SERIALIZED_NAME_PROOF = "proof";
  @SerializedName(SERIALIZED_NAME_PROOF)
  private List<ReceiptProofNode> proof = null;

  public static final String SERIALIZED_NAME_ANCHORS = "anchors";
  @SerializedName(SERIALIZED_NAME_ANCHORS)
  private List<ReceiptAnchorsNode> anchors = null;

  public static final String SERIALIZED_NAME_PARTIAL = "partial";
  @SerializedName(SERIALIZED_NAME_PARTIAL)
  private Boolean partial;

  public static final String SERIALIZED_NAME_SIGNATURE = "signature";
  @SerializedName(SERIALIZED_NAME_SIGNATURE)
  private ReceiptSignature signature;


  public Receipt targetHash(String targetHash) {
    
    this.targetHash = targetHash;
    return this;
  }

   /**
   * SHA256 hash of the proven data or signature.
   * @return targetHash
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "SHA256 hash of the proven data or signature.")

  public String getTargetHash() {
    return targetHash;
  }


  public void setTargetHash(String targetHash) {
    this.targetHash = targetHash;
  }


  public Receipt type(String type) {
    
    this.type = type;
    return this;
  }

   /**
   * Chainpoint 2.x: Type of the proof receipt.&lt;br&gt; **Currently only &#39;ChainpointSHA256v2&#39; is supported.** 
   * @return type
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Chainpoint 2.x: Type of the proof receipt.<br> **Currently only 'ChainpointSHA256v2' is supported.** ")

  public String getType() {
    return type;
  }


  public void setType(String type) {
    this.type = type;
  }


  public Receipt merkleRoot(String merkleRoot) {
    
    this.merkleRoot = merkleRoot;
    return this;
  }

   /**
   * Chainpoint 2.x: Root of the Merkle tree. 
   * @return merkleRoot
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Chainpoint 2.x: Root of the Merkle tree. ")

  public String getMerkleRoot() {
    return merkleRoot;
  }


  public void setMerkleRoot(String merkleRoot) {
    this.merkleRoot = merkleRoot;
  }


  public Receipt proof(List<ReceiptProofNode> proof) {
    
    this.proof = proof;
    return this;
  }

  public Receipt addProofItem(ReceiptProofNode proofItem) {
    if (this.proof == null) {
      this.proof = new ArrayList<ReceiptProofNode>();
    }
    this.proof.add(proofItem);
    return this;
  }

   /**
   * Chainpoint 2.x: Merkle proof (path from &#x60;targetHash&#x60; to &#x60;merkleRoot&#x60; in the Merkle tree). 
   * @return proof
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Chainpoint 2.x: Merkle proof (path from `targetHash` to `merkleRoot` in the Merkle tree). ")

  public List<ReceiptProofNode> getProof() {
    return proof;
  }


  public void setProof(List<ReceiptProofNode> proof) {
    this.proof = proof;
  }


  public Receipt anchors(List<ReceiptAnchorsNode> anchors) {
    
    this.anchors = anchors;
    return this;
  }

  public Receipt addAnchorsItem(ReceiptAnchorsNode anchorsItem) {
    if (this.anchors == null) {
      this.anchors = new ArrayList<ReceiptAnchorsNode>();
    }
    this.anchors.add(anchorsItem);
    return this;
  }

   /**
   * Chainpoint 2.x: List of sources where the root of the Merkle proof is anchored. 
   * @return anchors
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Chainpoint 2.x: List of sources where the root of the Merkle proof is anchored. ")

  public List<ReceiptAnchorsNode> getAnchors() {
    return anchors;
  }


  public void setAnchors(List<ReceiptAnchorsNode> anchors) {
    this.anchors = anchors;
  }


  public Receipt partial(Boolean partial) {
    
    this.partial = partial;
    return this;
  }

   /**
   * &#x60;true&#x60; if the receipt is partial (ie. does not contain the Chainpoint 2.x proof of timestamp) 
   * @return partial
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "`true` if the receipt is partial (ie. does not contain the Chainpoint 2.x proof of timestamp) ")

  public Boolean getPartial() {
    return partial;
  }


  public void setPartial(Boolean partial) {
    this.partial = partial;
  }


  public Receipt signature(ReceiptSignature signature) {
    
    this.signature = signature;
    return this;
  }

   /**
   * Get signature
   * @return signature
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ReceiptSignature getSignature() {
    return signature;
  }


  public void setSignature(ReceiptSignature signature) {
    this.signature = signature;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Receipt receipt = (Receipt) o;
    return Objects.equals(this.targetHash, receipt.targetHash) &&
        Objects.equals(this.type, receipt.type) &&
        Objects.equals(this.merkleRoot, receipt.merkleRoot) &&
        Objects.equals(this.proof, receipt.proof) &&
        Objects.equals(this.anchors, receipt.anchors) &&
        Objects.equals(this.partial, receipt.partial) &&
        Objects.equals(this.signature, receipt.signature);
  }

  @Override
  public int hashCode() {
    return Objects.hash(targetHash, type, merkleRoot, proof, anchors, partial, signature);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Receipt {\n");
    sb.append("    targetHash: ").append(toIndentedString(targetHash)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    merkleRoot: ").append(toIndentedString(merkleRoot)).append("\n");
    sb.append("    proof: ").append(toIndentedString(proof)).append("\n");
    sb.append("    anchors: ").append(toIndentedString(anchors)).append("\n");
    sb.append("    partial: ").append(toIndentedString(partial)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

