/*
 * Woleet API
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation. 
 *
 * OpenAPI spec version: 1.6.2
 * Contact: contact@woleet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.woleet.api.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Anchor
 */

public class Anchor {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private Long created;

  public static final String SERIALIZED_NAME_LAST_MODIFIED = "lastModified";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED)
  private Long lastModified;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_SIGNED_HASH = "signedHash";
  @SerializedName(SERIALIZED_NAME_SIGNED_HASH)
  private String signedHash;

  public static final String SERIALIZED_NAME_SIGNED_IDENTITY = "signedIdentity";
  @SerializedName(SERIALIZED_NAME_SIGNED_IDENTITY)
  private String signedIdentity;

  public static final String SERIALIZED_NAME_SIGNED_ISSUER_DOMAIN = "signedIssuerDomain";
  @SerializedName(SERIALIZED_NAME_SIGNED_ISSUER_DOMAIN)
  private String signedIssuerDomain;

  public static final String SERIALIZED_NAME_PUB_KEY = "pubKey";
  @SerializedName(SERIALIZED_NAME_PUB_KEY)
  private String pubKey;

  public static final String SERIALIZED_NAME_SIGNATURE = "signature";
  @SerializedName(SERIALIZED_NAME_SIGNATURE)
  private String signature;

  public static final String SERIALIZED_NAME_IDENTITY_U_R_L = "identityURL";
  @SerializedName(SERIALIZED_NAME_IDENTITY_U_R_L)
  private String identityURL;

  public static final String SERIALIZED_NAME_PUBLIC = "public";
  @SerializedName(SERIALIZED_NAME_PUBLIC)
  private Boolean _public;

  public static final String SERIALIZED_NAME_NOTIFY_BY_EMAIL = "notifyByEmail";
  @SerializedName(SERIALIZED_NAME_NOTIFY_BY_EMAIL)
  private Boolean notifyByEmail;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = null;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Object metadata = null;

  public static final String SERIALIZED_NAME_CALLBACK_U_R_L = "callbackURL";
  @SerializedName(SERIALIZED_NAME_CALLBACK_U_R_L)
  private String callbackURL;

  /**
   * Status of the anchor:&lt;br&gt; - WAIT: waiting to be processed by the platform (the proof receipt is not yet available for download)&lt;br&gt; - NEW: waiting to be sent to the blockchain (the proof receipt is not yet available for download)&lt;br&gt; - SENT: sent to the blockchain (the proof receipt can be downloaded)&lt;br&gt; - CONFIRMED: confirmed at least 6 times by the blockchain (the proof receipt can be verified) 
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    WAIT("WAIT"),
    
    NEW("NEW"),
    
    SENT("SENT"),
    
    CONFIRMED("CONFIRMED");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StatusEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private Long timestamp;

  public static final String SERIALIZED_NAME_CONFIRMATIONS = "confirmations";
  @SerializedName(SERIALIZED_NAME_CONFIRMATIONS)
  private Integer confirmations;

  public static final String SERIALIZED_NAME_TX_ID = "txId";
  @SerializedName(SERIALIZED_NAME_TX_ID)
  private String txId;

   /**
   * Anchor identifier. It is allocated by the platform, and so must not be provided at creation time. 
   * @return id
  **/
  @ApiModelProperty(value = "Anchor identifier. It is allocated by the platform, and so must not be provided at creation time. ")
  public String getId() {
    return id;
  }

   /**
   * Date of creation (in milliseconds since Unix epoch). 
   * @return created
  **/
  @ApiModelProperty(value = "Date of creation (in milliseconds since Unix epoch). ")
  public Long getCreated() {
    return created;
  }

   /**
   * Date of last modification (in milliseconds since Unix epoch). 
   * @return lastModified
  **/
  @ApiModelProperty(value = "Date of last modification (in milliseconds since Unix epoch). ")
  public Long getLastModified() {
    return lastModified;
  }

  public Anchor name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the anchor (doesn&#39;t need to be unique). 
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Name of the anchor (doesn't need to be unique). ")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Anchor hash(String hash) {
    this.hash = hash;
    return this;
  }

   /**
   * SHA256 hash (ie. the fingerprint) of the original data to anchor.&lt;br&gt; The value must be provided as an hexadecimal lowercase string.&lt;br&gt; **This property must not be provided when creating a signature anchor: it is set at creation time to the SHA256 hash of the &#x60;signature&#x60; property provided (so the signature is what is actually anchored in this case).** 
   * @return hash
  **/
  @ApiModelProperty(required = true, value = "SHA256 hash (ie. the fingerprint) of the original data to anchor.<br> The value must be provided as an hexadecimal lowercase string.<br> **This property must not be provided when creating a signature anchor: it is set at creation time to the SHA256 hash of the `signature` property provided (so the signature is what is actually anchored in this case).** ")
  public String getHash() {
    return hash;
  }

  public void setHash(String hash) {
    this.hash = hash;
  }

  public Anchor signedHash(String signedHash) {
    this.signedHash = signedHash;
    return this;
  }

   /**
   * SHA256 hash (ie. the fingerprint) of the original signed data.&lt;br&gt; The value must be provided as an hexadecimal lowercase string.&lt;br&gt; **This property must not be provided when creating a data anchor.** 
   * @return signedHash
  **/
  @ApiModelProperty(value = "SHA256 hash (ie. the fingerprint) of the original signed data.<br> The value must be provided as an hexadecimal lowercase string.<br> **This property must not be provided when creating a data anchor.** ")
  public String getSignedHash() {
    return signedHash;
  }

  public void setSignedHash(String signedHash) {
    this.signedHash = signedHash;
  }

  public Anchor signedIdentity(String signedIdentity) {
    this.signedIdentity = signedIdentity;
    return this;
  }

   /**
   * X500 Distinguished Name representing the signed identity.&lt;br&gt; **This property must not be provided when creating a data anchor.** 
   * @return signedIdentity
  **/
  @ApiModelProperty(value = "X500 Distinguished Name representing the signed identity.<br> **This property must not be provided when creating a data anchor.** ")
  public String getSignedIdentity() {
    return signedIdentity;
  }

  public void setSignedIdentity(String signedIdentity) {
    this.signedIdentity = signedIdentity;
  }

  public Anchor signedIssuerDomain(String signedIssuerDomain) {
    this.signedIssuerDomain = signedIssuerDomain;
    return this;
  }

   /**
   * Domain name of the identity issuer (ie. of the organization who verified the identity).&lt;br&gt; If set, the domain name of the identity URL must be included in the &#x60;signedIssuerDomain&#x60; domain name. **This property must not be provided when creating a data anchor.** 
   * @return signedIssuerDomain
  **/
  @ApiModelProperty(value = "Domain name of the identity issuer (ie. of the organization who verified the identity).<br> If set, the domain name of the identity URL must be included in the `signedIssuerDomain` domain name. **This property must not be provided when creating a data anchor.** ")
  public String getSignedIssuerDomain() {
    return signedIssuerDomain;
  }

  public void setSignedIssuerDomain(String signedIssuerDomain) {
    this.signedIssuerDomain = signedIssuerDomain;
  }

  public Anchor pubKey(String pubKey) {
    this.pubKey = pubKey;
    return this;
  }

   /**
   * Public key of the signee.&lt;br&gt; **Currently only Bitcoin addresses are supported.**&lt;br&gt; **This property must not be provided when creating a data anchor.** 
   * @return pubKey
  **/
  @ApiModelProperty(value = "Public key of the signee.<br> **Currently only Bitcoin addresses are supported.**<br> **This property must not be provided when creating a data anchor.** ")
  public String getPubKey() {
    return pubKey;
  }

  public void setPubKey(String pubKey) {
    this.pubKey = pubKey;
  }

  public Anchor signature(String signature) {
    this.signature = signature;
    return this;
  }

   /**
   * Signature of the &#x60;signedHash&#x60; property using the public key &#x60;pubKey&#x60;, or, if any of &#x60;signedIdentity&#x60; or &#x60;signedIssuerDomain&#x60; is provided, signature of SHA256(&#x60;hashToSign&#x60; + &#x60;signedIdentity&#x60; + &#x60;signedIssuerDomain&#x60;) using the public key &#x60;pubKey&#x60;.&lt;br&gt; **Only Bitcoin signatures are currently supported.**&lt;br&gt; **This property must not be provided when creating a data anchor.** 
   * @return signature
  **/
  @ApiModelProperty(value = "Signature of the `signedHash` property using the public key `pubKey`, or, if any of `signedIdentity` or `signedIssuerDomain` is provided, signature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.<br> **Only Bitcoin signatures are currently supported.**<br> **This property must not be provided when creating a data anchor.** ")
  public String getSignature() {
    return signature;
  }

  public void setSignature(String signature) {
    this.signature = signature;
  }

  public Anchor identityURL(String identityURL) {
    this.identityURL = identityURL;
    return this;
  }

   /**
   * Web hook of the identity server to use to verify the signee&#39;s identity.&lt;br&gt; This URL allows to retrieve the identity associated to the public key &#x60;pubKey&#x60;. It can also be used to verify that the identity server (itself identified by the TLS certificate of the URL) controls the key used to sign (ie. owns the private part of the key pair) by requesting it to sign some random data.&lt;br&gt; This URL MUST use an HTTPS scheme with a valid and non expired TLS certificate.&lt;br&gt; This URL MUST implement the following GET operation:&lt;br&gt; Query parameters:&lt;br&gt; - &#x60;pubKey&#x60;: the public key to be verified - mandatory&lt;br&gt; - &#x60;leftData&#x60;: the left part of the data to be signed (generated randomly by the caller) - if set, the identity server MAY provide a &#x60;signature&#x60;&lt;br&gt; Output:&lt;br&gt; A JSON object with: - &#x60;rightData&#x60;: the right part of the data signed (generated randomly by the identity server) - optional&lt;br&gt; - &#x60;signature&#x60;: the signature of the string &#x60;leftData&#x60; + &#x60;rightData&#x60; using the public key &#x60;pubKey&#x60; - optional&lt;br&gt; - &#x60;identity&#x60;: the X500 identity associated to the key claimed by the identity server - optional&lt;br&gt; - &#x60;key&#x60;: additional information about the key - optional&lt;br&gt; If &#x60;identity&#x60; is not provided, &#x60;signature&#x60; and &#x60;rightData&#x60; MUST be provided: in such a case the identity of the signee can be extracted from the TLS certificate. 
   * @return identityURL
  **/
  @ApiModelProperty(value = "Web hook of the identity server to use to verify the signee's identity.<br> This URL allows to retrieve the identity associated to the public key `pubKey`. It can also be used to verify that the identity server (itself identified by the TLS certificate of the URL) controls the key used to sign (ie. owns the private part of the key pair) by requesting it to sign some random data.<br> This URL MUST use an HTTPS scheme with a valid and non expired TLS certificate.<br> This URL MUST implement the following GET operation:<br> Query parameters:<br> - `pubKey`: the public key to be verified - mandatory<br> - `leftData`: the left part of the data to be signed (generated randomly by the caller) - if set, the identity server MAY provide a `signature`<br> Output:<br> A JSON object with: - `rightData`: the right part of the data signed (generated randomly by the identity server) - optional<br> - `signature`: the signature of the string `leftData` + `rightData` using the public key `pubKey` - optional<br> - `identity`: the X500 identity associated to the key claimed by the identity server - optional<br> - `key`: additional information about the key - optional<br> If `identity` is not provided, `signature` and `rightData` MUST be provided: in such a case the identity of the signee can be extracted from the TLS certificate. ")
  public String getIdentityURL() {
    return identityURL;
  }

  public void setIdentityURL(String identityURL) {
    this.identityURL = identityURL;
  }

  public Anchor _public(Boolean _public) {
    this._public = _public;
    return this;
  }

   /**
   * &#x60;true&#x60; (or unset) if the anchor is public (ie. discoverable by its &#x60;hash&#x60; or &#x60;signedHash&#x60;).&lt;br&gt; &#x60;false&#x60; if it must be private (ie. not discoverable).&lt;br&gt; **If this field is not set at creation time, the anchor is public by default.** 
   * @return _public
  **/
  @ApiModelProperty(value = "`true` (or unset) if the anchor is public (ie. discoverable by its `hash` or `signedHash`).<br> `false` if it must be private (ie. not discoverable).<br> **If this field is not set at creation time, the anchor is public by default.** ")
  public Boolean getPublic() {
    return _public;
  }

  public void setPublic(Boolean _public) {
    this._public = _public;
  }

  public Anchor notifyByEmail(Boolean notifyByEmail) {
    this.notifyByEmail = notifyByEmail;
    return this;
  }

   /**
   * &#x60;true&#x60; if the proof receipt must be sent by email once available, or &#x60;false&#x60; (or unset) if not. 
   * @return notifyByEmail
  **/
  @ApiModelProperty(value = "`true` if the proof receipt must be sent by email once available, or `false` (or unset) if not. ")
  public Boolean getNotifyByEmail() {
    return notifyByEmail;
  }

  public void setNotifyByEmail(Boolean notifyByEmail) {
    this.notifyByEmail = notifyByEmail;
  }

  public Anchor tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public Anchor addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<String>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * Set of tags associated to the anchor. There is no restriction on tag names, except they cannot contain spaces.&lt;br&gt; Tags are aimed at classifying and searching anchors. 
   * @return tags
  **/
  @ApiModelProperty(value = "Set of tags associated to the anchor. There is no restriction on tag names, except they cannot contain spaces.<br> Tags are aimed at classifying and searching anchors. ")
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }

  public Anchor metadata(Object metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * A JSON object containing a set of key/values to store with the anchor and giving additional information about the anchored data.&lt;br&gt; Values must be of type null, boolean, string or number: nested JSON objects are not allowed.&lt;br&gt; ex: { title: &#39;Ubik&#39;, author: &#39;Philip K. Dick&#39;, read: true, rank: 10.0, coauthor: null } 
   * @return metadata
  **/
  @ApiModelProperty(value = "A JSON object containing a set of key/values to store with the anchor and giving additional information about the anchored data.<br> Values must be of type null, boolean, string or number: nested JSON objects are not allowed.<br> ex: { title: 'Ubik', author: 'Philip K. Dick', read: true, rank: 10.0, coauthor: null } ")
  public Object getMetadata() {
    return metadata;
  }

  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }

  public Anchor callbackURL(String callbackURL) {
    this.callbackURL = callbackURL;
    return this;
  }

   /**
   * Web hook to be called by the platform whenever the anchor status change:&lt;br&gt; the platform does a POST request on this URL with the anchor as a JSON object in the request body.&lt;br&gt; Verifying the authenticity of the callback can be done by checking the HMAC-SHA1 signature of the request body provided by Woleet in the &#x60;x-woleet-signature&#x60; header.&lt;br&gt; For more information see the &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://doc.woleet.io/reference#using-callbacks\&quot;&gt;documentation&lt;/a&gt;. 
   * @return callbackURL
  **/
  @ApiModelProperty(value = "Web hook to be called by the platform whenever the anchor status change:<br> the platform does a POST request on this URL with the anchor as a JSON object in the request body.<br> Verifying the authenticity of the callback can be done by checking the HMAC-SHA1 signature of the request body provided by Woleet in the `x-woleet-signature` header.<br> For more information see the <a target=\"_blank\" href=\"https://doc.woleet.io/reference#using-callbacks\">documentation</a>. ")
  public String getCallbackURL() {
    return callbackURL;
  }

  public void setCallbackURL(String callbackURL) {
    this.callbackURL = callbackURL;
  }

   /**
   * Status of the anchor:&lt;br&gt; - WAIT: waiting to be processed by the platform (the proof receipt is not yet available for download)&lt;br&gt; - NEW: waiting to be sent to the blockchain (the proof receipt is not yet available for download)&lt;br&gt; - SENT: sent to the blockchain (the proof receipt can be downloaded)&lt;br&gt; - CONFIRMED: confirmed at least 6 times by the blockchain (the proof receipt can be verified) 
   * @return status
  **/
  @ApiModelProperty(value = "Status of the anchor:<br> - WAIT: waiting to be processed by the platform (the proof receipt is not yet available for download)<br> - NEW: waiting to be sent to the blockchain (the proof receipt is not yet available for download)<br> - SENT: sent to the blockchain (the proof receipt can be downloaded)<br> - CONFIRMED: confirmed at least 6 times by the blockchain (the proof receipt can be verified) ")
  public StatusEnum getStatus() {
    return status;
  }

   /**
   * Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).&lt;br&gt; This is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).&lt;br&gt; Any data whose SHA256 hash equals this anchor&#39;s hash is proven to exist at that time and has not been modified since.&lt;br&gt; This field is set when the first confirmation of the Bitcoin block occurs. Once set, the associated proof receipt can be verified (without having to wait for 6 confirmations). 
   * @return timestamp
  **/
  @ApiModelProperty(value = "Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).<br> This is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).<br> Any data whose SHA256 hash equals this anchor's hash is proven to exist at that time and has not been modified since.<br> This field is set when the first confirmation of the Bitcoin block occurs. Once set, the associated proof receipt can be verified (without having to wait for 6 confirmations). ")
  public Long getTimestamp() {
    return timestamp;
  }

   /**
   * Number of confirmations of the Bitcoin block into which the anchoring process occurred.&lt;br&gt; This field is set when the first confirmation of the Bitcoin block occurs, and removed once the block is confirmed at least 6 times. 
   * @return confirmations
  **/
  @ApiModelProperty(value = "Number of confirmations of the Bitcoin block into which the anchoring process occurred.<br> This field is set when the first confirmation of the Bitcoin block occurs, and removed once the block is confirmed at least 6 times. ")
  public Integer getConfirmations() {
    return confirmations;
  }

   /**
   * Identifier of the Bitcoin transaction where the anchoring occurred. 
   * @return txId
  **/
  @ApiModelProperty(value = "Identifier of the Bitcoin transaction where the anchoring occurred. ")
  public String getTxId() {
    return txId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Anchor anchor = (Anchor) o;
    return Objects.equals(this.id, anchor.id) &&
        Objects.equals(this.created, anchor.created) &&
        Objects.equals(this.lastModified, anchor.lastModified) &&
        Objects.equals(this.name, anchor.name) &&
        Objects.equals(this.hash, anchor.hash) &&
        Objects.equals(this.signedHash, anchor.signedHash) &&
        Objects.equals(this.signedIdentity, anchor.signedIdentity) &&
        Objects.equals(this.signedIssuerDomain, anchor.signedIssuerDomain) &&
        Objects.equals(this.pubKey, anchor.pubKey) &&
        Objects.equals(this.signature, anchor.signature) &&
        Objects.equals(this.identityURL, anchor.identityURL) &&
        Objects.equals(this._public, anchor._public) &&
        Objects.equals(this.notifyByEmail, anchor.notifyByEmail) &&
        Objects.equals(this.tags, anchor.tags) &&
        Objects.equals(this.metadata, anchor.metadata) &&
        Objects.equals(this.callbackURL, anchor.callbackURL) &&
        Objects.equals(this.status, anchor.status) &&
        Objects.equals(this.timestamp, anchor.timestamp) &&
        Objects.equals(this.confirmations, anchor.confirmations) &&
        Objects.equals(this.txId, anchor.txId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, created, lastModified, name, hash, signedHash, signedIdentity, signedIssuerDomain, pubKey, signature, identityURL, _public, notifyByEmail, tags, metadata, callbackURL, status, timestamp, confirmations, txId);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Anchor {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    lastModified: ").append(toIndentedString(lastModified)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    signedHash: ").append(toIndentedString(signedHash)).append("\n");
    sb.append("    signedIdentity: ").append(toIndentedString(signedIdentity)).append("\n");
    sb.append("    signedIssuerDomain: ").append(toIndentedString(signedIssuerDomain)).append("\n");
    sb.append("    pubKey: ").append(toIndentedString(pubKey)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("    identityURL: ").append(toIndentedString(identityURL)).append("\n");
    sb.append("    _public: ").append(toIndentedString(_public)).append("\n");
    sb.append("    notifyByEmail: ").append(toIndentedString(notifyByEmail)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    callbackURL: ").append(toIndentedString(callbackURL)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    confirmations: ").append(toIndentedString(confirmations)).append("\n");
    sb.append("    txId: ").append(toIndentedString(txId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

