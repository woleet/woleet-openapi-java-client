/*
 * Woleet API
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation. 
 *
 * OpenAPI spec version: 1.6.1
 * Contact: contact@woleet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.woleet.api.client;

import io.woleet.api.ApiCallback;
import io.woleet.api.ApiClient;
import io.woleet.api.ApiException;
import io.woleet.api.ApiResponse;
import io.woleet.api.Configuration;
import io.woleet.api.Pair;
import io.woleet.api.ProgressRequestBody;
import io.woleet.api.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.woleet.api.client.model.Anchor;
import io.woleet.api.client.model.AnchorIds;
import io.woleet.api.client.model.Anchors;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AnchorApi {
    private ApiClient apiClient;

    public AnchorApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AnchorApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createAnchor
     * @param anchor Anchor object to create. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call createAnchorCall(Anchor anchor, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = anchor;

        // create path and map variables
        String localVarPath = "/anchor";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createAnchorValidateBeforeCall(Anchor anchor, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'anchor' is set
        if (anchor == null) {
            throw new ApiException("Missing the required parameter 'anchor' when calling createAnchor(Async)");
        }
        

        com.squareup.okhttp.Call call = createAnchorCall(anchor, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Create a new anchor.
     * Use this operation to create a new anchor of one of these two types:&lt;br&gt;  - a data anchor (generating a proof of existence receipt) allows to prove the existence of some data at some point in time.&lt;br&gt; - a signature anchor (generating a proof of signature receipt) allows to prove the existence of the signature of some data at some point in time, the validity of the signature and the signee&#39;s identity.&lt;br&gt;  The properties &#x60;id&#x60;, &#x60;created&#x60;, &#x60;lastModified&#x60;, &#x60;status&#x60;, &#x60;timestamp&#x60; and &#x60;confirmations&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned anchor.&lt;br&gt; For data anchors, only the properties &#x60;name&#x60; and &#x60;hash&#x60; are required: the &#x60;hash&#x60; property must be the SHA256 hash of the data to anchor, and must be computed caller side. This allows not to leak the original data.&lt;br&gt; For signature anchors, only the properties &#x60;name&#x60;, &#x60;signedHash&#x60;, &#x60;signature&#x60; and &#x60;pubKey&#x60; are required (though the &#x60;identityURL&#x60; property is highly recommended): the &#x60;signedHash&#x60; property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).&lt;br&gt; Be sure to have at least 1 anchoring credit on your account. The &#x60;signature&#x60; property must contain a valid signature of the &#x60;data&#x60; property using the private key paired with the &#x60;pubKey&#x60; public key. 
     * @param anchor Anchor object to create. (required)
     * @return Anchor
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Anchor createAnchor(Anchor anchor) throws ApiException {
        ApiResponse<Anchor> resp = createAnchorWithHttpInfo(anchor);
        return resp.getData();
    }

    /**
     * Create a new anchor.
     * Use this operation to create a new anchor of one of these two types:&lt;br&gt;  - a data anchor (generating a proof of existence receipt) allows to prove the existence of some data at some point in time.&lt;br&gt; - a signature anchor (generating a proof of signature receipt) allows to prove the existence of the signature of some data at some point in time, the validity of the signature and the signee&#39;s identity.&lt;br&gt;  The properties &#x60;id&#x60;, &#x60;created&#x60;, &#x60;lastModified&#x60;, &#x60;status&#x60;, &#x60;timestamp&#x60; and &#x60;confirmations&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned anchor.&lt;br&gt; For data anchors, only the properties &#x60;name&#x60; and &#x60;hash&#x60; are required: the &#x60;hash&#x60; property must be the SHA256 hash of the data to anchor, and must be computed caller side. This allows not to leak the original data.&lt;br&gt; For signature anchors, only the properties &#x60;name&#x60;, &#x60;signedHash&#x60;, &#x60;signature&#x60; and &#x60;pubKey&#x60; are required (though the &#x60;identityURL&#x60; property is highly recommended): the &#x60;signedHash&#x60; property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).&lt;br&gt; Be sure to have at least 1 anchoring credit on your account. The &#x60;signature&#x60; property must contain a valid signature of the &#x60;data&#x60; property using the private key paired with the &#x60;pubKey&#x60; public key. 
     * @param anchor Anchor object to create. (required)
     * @return ApiResponse&lt;Anchor&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Anchor> createAnchorWithHttpInfo(Anchor anchor) throws ApiException {
        com.squareup.okhttp.Call call = createAnchorValidateBeforeCall(anchor, null, null);
        Type localVarReturnType = new TypeToken<Anchor>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create a new anchor. (asynchronously)
     * Use this operation to create a new anchor of one of these two types:&lt;br&gt;  - a data anchor (generating a proof of existence receipt) allows to prove the existence of some data at some point in time.&lt;br&gt; - a signature anchor (generating a proof of signature receipt) allows to prove the existence of the signature of some data at some point in time, the validity of the signature and the signee&#39;s identity.&lt;br&gt;  The properties &#x60;id&#x60;, &#x60;created&#x60;, &#x60;lastModified&#x60;, &#x60;status&#x60;, &#x60;timestamp&#x60; and &#x60;confirmations&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned anchor.&lt;br&gt; For data anchors, only the properties &#x60;name&#x60; and &#x60;hash&#x60; are required: the &#x60;hash&#x60; property must be the SHA256 hash of the data to anchor, and must be computed caller side. This allows not to leak the original data.&lt;br&gt; For signature anchors, only the properties &#x60;name&#x60;, &#x60;signedHash&#x60;, &#x60;signature&#x60; and &#x60;pubKey&#x60; are required (though the &#x60;identityURL&#x60; property is highly recommended): the &#x60;signedHash&#x60; property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).&lt;br&gt; Be sure to have at least 1 anchoring credit on your account. The &#x60;signature&#x60; property must contain a valid signature of the &#x60;data&#x60; property using the private key paired with the &#x60;pubKey&#x60; public key. 
     * @param anchor Anchor object to create. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createAnchorAsync(Anchor anchor, final ApiCallback<Anchor> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createAnchorValidateBeforeCall(anchor, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Anchor>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deleteAnchor
     * @param anchorId Identifier of the anchor to delete. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deleteAnchorCall(String anchorId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/anchor/{anchorId}"
            .replaceAll("\\{" + "anchorId" + "\\}", apiClient.escapeString(anchorId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteAnchorValidateBeforeCall(String anchorId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'anchorId' is set
        if (anchorId == null) {
            throw new ApiException("Missing the required parameter 'anchorId' when calling deleteAnchor(Async)");
        }
        

        com.squareup.okhttp.Call call = deleteAnchorCall(anchorId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Delete an anchor.
     * Use this operation to delete an anchor.&lt;br&gt; **WARNING: You should never delete an anchor, otherwise you will no longer be able to download its proof receipt.&lt;br&gt; Use this for test purpose only.** 
     * @param anchorId Identifier of the anchor to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteAnchor(String anchorId) throws ApiException {
        deleteAnchorWithHttpInfo(anchorId);
    }

    /**
     * Delete an anchor.
     * Use this operation to delete an anchor.&lt;br&gt; **WARNING: You should never delete an anchor, otherwise you will no longer be able to download its proof receipt.&lt;br&gt; Use this for test purpose only.** 
     * @param anchorId Identifier of the anchor to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteAnchorWithHttpInfo(String anchorId) throws ApiException {
        com.squareup.okhttp.Call call = deleteAnchorValidateBeforeCall(anchorId, null, null);
        return apiClient.execute(call);
    }

    /**
     * Delete an anchor. (asynchronously)
     * Use this operation to delete an anchor.&lt;br&gt; **WARNING: You should never delete an anchor, otherwise you will no longer be able to download its proof receipt.&lt;br&gt; Use this for test purpose only.** 
     * @param anchorId Identifier of the anchor to delete. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteAnchorAsync(String anchorId, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteAnchorValidateBeforeCall(anchorId, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for getAnchor
     * @param anchorId Identifier of the anchor to retrieve. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getAnchorCall(String anchorId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/anchor/{anchorId}"
            .replaceAll("\\{" + "anchorId" + "\\}", apiClient.escapeString(anchorId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getAnchorValidateBeforeCall(String anchorId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'anchorId' is set
        if (anchorId == null) {
            throw new ApiException("Missing the required parameter 'anchorId' when calling getAnchor(Async)");
        }
        

        com.squareup.okhttp.Call call = getAnchorCall(anchorId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get an anchor by its identifier.
     * Use this operation to retrieve an anchor by its identifier.
     * @param anchorId Identifier of the anchor to retrieve. (required)
     * @return Anchor
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Anchor getAnchor(String anchorId) throws ApiException {
        ApiResponse<Anchor> resp = getAnchorWithHttpInfo(anchorId);
        return resp.getData();
    }

    /**
     * Get an anchor by its identifier.
     * Use this operation to retrieve an anchor by its identifier.
     * @param anchorId Identifier of the anchor to retrieve. (required)
     * @return ApiResponse&lt;Anchor&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Anchor> getAnchorWithHttpInfo(String anchorId) throws ApiException {
        com.squareup.okhttp.Call call = getAnchorValidateBeforeCall(anchorId, null, null);
        Type localVarReturnType = new TypeToken<Anchor>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get an anchor by its identifier. (asynchronously)
     * Use this operation to retrieve an anchor by its identifier.
     * @param anchorId Identifier of the anchor to retrieve. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getAnchorAsync(String anchorId, final ApiCallback<Anchor> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getAnchorValidateBeforeCall(anchorId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Anchor>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchAnchorIds
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param hash &#x60;hash&#x60; to search for: all public anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all public anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call searchAnchorIdsCall(Integer page, Integer size, String hash, String signedHash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/anchorids";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
        }

        if (hash != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("hash", hash));
        }

        if (signedHash != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("signedHash", signedHash));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call searchAnchorIdsValidateBeforeCall(Integer page, Integer size, String hash, String signedHash, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = searchAnchorIdsCall(page, size, hash, signedHash, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Search for public anchors&#39; identifiers.
     * Use this operation to retrieve the identifiers of all public anchors having a given &#x60;hash&#x60; and/or &#x60;signedHash&#x60; property.&lt;br&gt; Only public anchors&#39; identifiers are returned.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve public anchors&#39; identifiers.&lt;br&gt; Paging is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param hash &#x60;hash&#x60; to search for: all public anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all public anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @return AnchorIds
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AnchorIds searchAnchorIds(Integer page, Integer size, String hash, String signedHash) throws ApiException {
        ApiResponse<AnchorIds> resp = searchAnchorIdsWithHttpInfo(page, size, hash, signedHash);
        return resp.getData();
    }

    /**
     * Search for public anchors&#39; identifiers.
     * Use this operation to retrieve the identifiers of all public anchors having a given &#x60;hash&#x60; and/or &#x60;signedHash&#x60; property.&lt;br&gt; Only public anchors&#39; identifiers are returned.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve public anchors&#39; identifiers.&lt;br&gt; Paging is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param hash &#x60;hash&#x60; to search for: all public anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all public anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @return ApiResponse&lt;AnchorIds&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AnchorIds> searchAnchorIdsWithHttpInfo(Integer page, Integer size, String hash, String signedHash) throws ApiException {
        com.squareup.okhttp.Call call = searchAnchorIdsValidateBeforeCall(page, size, hash, signedHash, null, null);
        Type localVarReturnType = new TypeToken<AnchorIds>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Search for public anchors&#39; identifiers. (asynchronously)
     * Use this operation to retrieve the identifiers of all public anchors having a given &#x60;hash&#x60; and/or &#x60;signedHash&#x60; property.&lt;br&gt; Only public anchors&#39; identifiers are returned.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve public anchors&#39; identifiers.&lt;br&gt; Paging is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param hash &#x60;hash&#x60; to search for: all public anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all public anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call searchAnchorIdsAsync(Integer page, Integer size, String hash, String signedHash, final ApiCallback<AnchorIds> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = searchAnchorIdsValidateBeforeCall(page, size, hash, signedHash, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AnchorIds>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for searchAnchors
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60;, &#x60;hash&#x60; and &#x60;signedHash&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all anchors whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large anchor set.**  (optional)
     * @param hash &#x60;hash&#x60; to search for: all anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @param tags &#x60;tags&#x60; to search for: all anchors having all of these tags sets are returned.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call searchAnchorsCall(Integer page, Integer size, String direction, String sort, String name, String hash, String signedHash, List<String> tags, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = new Object();

        // create path and map variables
        String localVarPath = "/anchors";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
        }

        if (direction != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("direction", direction));
        }

        if (sort != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        }

        if (name != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("name", name));
        }

        if (hash != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("hash", hash));
        }

        if (signedHash != null) {
            localVarQueryParams.addAll(apiClient.parameterToPair("signedHash", signedHash));
        }

        if (tags != null) {
            localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "tags", tags));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call searchAnchorsValidateBeforeCall(Integer page, Integer size, String direction, String sort, String name, String hash, String signedHash, List<String> tags, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = searchAnchorsCall(page, size, direction, sort, name, hash, signedHash, tags, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Search for anchors.
     * Use this operation to retrieve all anchors having a given &#x60;name&#x60;, &#x60;hash&#x60;, &#x60;signedHash&#x60; and/or &#x60;tags&#x60; property.&lt;br&gt; Only anchors belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60;, &#x60;hash&#x60; and &#x60;signedHash&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all anchors whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large anchor set.**  (optional)
     * @param hash &#x60;hash&#x60; to search for: all anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @param tags &#x60;tags&#x60; to search for: all anchors having all of these tags sets are returned.  (optional)
     * @return Anchors
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Anchors searchAnchors(Integer page, Integer size, String direction, String sort, String name, String hash, String signedHash, List<String> tags) throws ApiException {
        ApiResponse<Anchors> resp = searchAnchorsWithHttpInfo(page, size, direction, sort, name, hash, signedHash, tags);
        return resp.getData();
    }

    /**
     * Search for anchors.
     * Use this operation to retrieve all anchors having a given &#x60;name&#x60;, &#x60;hash&#x60;, &#x60;signedHash&#x60; and/or &#x60;tags&#x60; property.&lt;br&gt; Only anchors belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60;, &#x60;hash&#x60; and &#x60;signedHash&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all anchors whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large anchor set.**  (optional)
     * @param hash &#x60;hash&#x60; to search for: all anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @param tags &#x60;tags&#x60; to search for: all anchors having all of these tags sets are returned.  (optional)
     * @return ApiResponse&lt;Anchors&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Anchors> searchAnchorsWithHttpInfo(Integer page, Integer size, String direction, String sort, String name, String hash, String signedHash, List<String> tags) throws ApiException {
        com.squareup.okhttp.Call call = searchAnchorsValidateBeforeCall(page, size, direction, sort, name, hash, signedHash, tags, null, null);
        Type localVarReturnType = new TypeToken<Anchors>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Search for anchors. (asynchronously)
     * Use this operation to retrieve all anchors having a given &#x60;name&#x60;, &#x60;hash&#x60;, &#x60;signedHash&#x60; and/or &#x60;tags&#x60; property.&lt;br&gt; Only anchors belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60;, &#x60;hash&#x60; and &#x60;signedHash&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all anchors whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large anchor set.**  (optional)
     * @param hash &#x60;hash&#x60; to search for: all anchors whose &#x60;hash&#x60; property is equal are returned.  (optional)
     * @param signedHash &#x60;signedHash&#x60; to search for: all anchors whose &#x60;signedHash&#x60; property is equal are returned.  (optional)
     * @param tags &#x60;tags&#x60; to search for: all anchors having all of these tags sets are returned.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call searchAnchorsAsync(Integer page, Integer size, String direction, String sort, String name, String hash, String signedHash, List<String> tags, final ApiCallback<Anchors> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = searchAnchorsValidateBeforeCall(page, size, direction, sort, name, hash, signedHash, tags, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Anchors>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateAnchor
     * @param anchorId Identifier of anchor to update. (required)
     * @param anchor Anchor object to update. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call updateAnchorCall(String anchorId, Anchor anchor, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = anchor;

        // create path and map variables
        String localVarPath = "/anchor/{anchorId}"
            .replaceAll("\\{" + "anchorId" + "\\}", apiClient.escapeString(anchorId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call updateAnchorValidateBeforeCall(String anchorId, Anchor anchor, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'anchorId' is set
        if (anchorId == null) {
            throw new ApiException("Missing the required parameter 'anchorId' when calling updateAnchor(Async)");
        }
        
        // verify the required parameter 'anchor' is set
        if (anchor == null) {
            throw new ApiException("Missing the required parameter 'anchor' when calling updateAnchor(Async)");
        }
        

        com.squareup.okhttp.Call call = updateAnchorCall(anchorId, anchor, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update an anchor.
     * Use this operation to update an anchor.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;metadata&#x60; and &#x60;callbackURL&#x60; can be modified. 
     * @param anchorId Identifier of anchor to update. (required)
     * @param anchor Anchor object to update. (required)
     * @return Anchor
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Anchor updateAnchor(String anchorId, Anchor anchor) throws ApiException {
        ApiResponse<Anchor> resp = updateAnchorWithHttpInfo(anchorId, anchor);
        return resp.getData();
    }

    /**
     * Update an anchor.
     * Use this operation to update an anchor.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;metadata&#x60; and &#x60;callbackURL&#x60; can be modified. 
     * @param anchorId Identifier of anchor to update. (required)
     * @param anchor Anchor object to update. (required)
     * @return ApiResponse&lt;Anchor&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Anchor> updateAnchorWithHttpInfo(String anchorId, Anchor anchor) throws ApiException {
        com.squareup.okhttp.Call call = updateAnchorValidateBeforeCall(anchorId, anchor, null, null);
        Type localVarReturnType = new TypeToken<Anchor>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an anchor. (asynchronously)
     * Use this operation to update an anchor.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;metadata&#x60; and &#x60;callbackURL&#x60; can be modified. 
     * @param anchorId Identifier of anchor to update. (required)
     * @param anchor Anchor object to update. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call updateAnchorAsync(String anchorId, Anchor anchor, final ApiCallback<Anchor> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = updateAnchorValidateBeforeCall(anchorId, anchor, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Anchor>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
