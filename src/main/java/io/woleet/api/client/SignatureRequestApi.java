/*
 * Woleet API
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation. 
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: contact@woleet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.woleet.api.client;

import io.woleet.api.ApiCallback;
import io.woleet.api.ApiClient;
import io.woleet.api.ApiException;
import io.woleet.api.ApiResponse;
import io.woleet.api.Configuration;
import io.woleet.api.Pair;
import io.woleet.api.ProgressRequestBody;
import io.woleet.api.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.woleet.api.client.model.SignatureRequest;
import io.woleet.api.client.model.SignatureRequestSign;
import io.woleet.api.client.model.SignatureRequestSignResult;
import io.woleet.api.client.model.SignatureRequests;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SignatureRequestApi {
    private ApiClient localVarApiClient;

    public SignatureRequestApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SignatureRequestApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for createSignatureRequest
     * @param signatureRequest SignatureRequest object to create. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSignatureRequestCall(SignatureRequest signatureRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequest;

        // create path and map variables
        String localVarPath = "/signatureRequest";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSignatureRequestValidateBeforeCall(SignatureRequest signatureRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'signatureRequest' is set
        if (signatureRequest == null) {
            throw new ApiException("Missing the required parameter 'signatureRequest' when calling createSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = createSignatureRequestCall(signatureRequest, _callback);
        return localVarCall;

    }

    /**
     * Create a new signature request.
     * Use this operation to create a new signature request.&lt;br&gt; The properties &#x60;id&#x60;, &#x60;created&#x60; and &#x60;lastModified&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned request.&lt;br&gt; Only the properties &#x60;name&#x60; and &#x60;hashToSign&#x60; are required: the &#x60;hashToSign&#x60; property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).&lt;br&gt; Be sure to have enough signature and anchoring credits on your account to fulfill the signature request (each registered signature will cost you 1 signature and 1 anchoring credit).&lt;br&gt; 
     * @param signatureRequest SignatureRequest object to create. (required)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest createSignatureRequest(SignatureRequest signatureRequest) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = createSignatureRequestWithHttpInfo(signatureRequest);
        return localVarResp.getData();
    }

    /**
     * Create a new signature request.
     * Use this operation to create a new signature request.&lt;br&gt; The properties &#x60;id&#x60;, &#x60;created&#x60; and &#x60;lastModified&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned request.&lt;br&gt; Only the properties &#x60;name&#x60; and &#x60;hashToSign&#x60; are required: the &#x60;hashToSign&#x60; property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).&lt;br&gt; Be sure to have enough signature and anchoring credits on your account to fulfill the signature request (each registered signature will cost you 1 signature and 1 anchoring credit).&lt;br&gt; 
     * @param signatureRequest SignatureRequest object to create. (required)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> createSignatureRequestWithHttpInfo(SignatureRequest signatureRequest) throws ApiException {
        okhttp3.Call localVarCall = createSignatureRequestValidateBeforeCall(signatureRequest, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a new signature request. (asynchronously)
     * Use this operation to create a new signature request.&lt;br&gt; The properties &#x60;id&#x60;, &#x60;created&#x60; and &#x60;lastModified&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned request.&lt;br&gt; Only the properties &#x60;name&#x60; and &#x60;hashToSign&#x60; are required: the &#x60;hashToSign&#x60; property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).&lt;br&gt; Be sure to have enough signature and anchoring credits on your account to fulfill the signature request (each registered signature will cost you 1 signature and 1 anchoring credit).&lt;br&gt; 
     * @param signatureRequest SignatureRequest object to create. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSignatureRequestAsync(SignatureRequest signatureRequest, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = createSignatureRequestValidateBeforeCall(signatureRequest, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteSignatureRequest
     * @param requestId Identifier of the signature request to delete. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSignatureRequestCall(String requestId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSignatureRequestValidateBeforeCall(String requestId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling deleteSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = deleteSignatureRequestCall(requestId, _callback);
        return localVarCall;

    }

    /**
     * Delete a signature request.
     * Use this operation to delete a signature request.&lt;br&gt; 
     * @param requestId Identifier of the signature request to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteSignatureRequest(String requestId) throws ApiException {
        deleteSignatureRequestWithHttpInfo(requestId);
    }

    /**
     * Delete a signature request.
     * Use this operation to delete a signature request.&lt;br&gt; 
     * @param requestId Identifier of the signature request to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteSignatureRequestWithHttpInfo(String requestId) throws ApiException {
        okhttp3.Call localVarCall = deleteSignatureRequestValidateBeforeCall(requestId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a signature request. (asynchronously)
     * Use this operation to delete a signature request.&lt;br&gt; 
     * @param requestId Identifier of the signature request to delete. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSignatureRequestAsync(String requestId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSignatureRequestValidateBeforeCall(requestId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSignatureRequest
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signee is returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (signeeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("signeeId", signeeId));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSignatureRequestValidateBeforeCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling getSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = getSignatureRequestCall(requestId, signeeId, _callback);
        return localVarCall;

    }

    /**
     * Get a signature request by its identifier.
     * Use this operation to retrieve a signature request by its identifier.&lt;br&gt; When accessed with no authentication, only public attributes of the signature request are returned. 
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signee is returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (optional)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest getSignatureRequest(String requestId, String signeeId) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = getSignatureRequestWithHttpInfo(requestId, signeeId);
        return localVarResp.getData();
    }

    /**
     * Get a signature request by its identifier.
     * Use this operation to retrieve a signature request by its identifier.&lt;br&gt; When accessed with no authentication, only public attributes of the signature request are returned. 
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signee is returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (optional)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> getSignatureRequestWithHttpInfo(String requestId, String signeeId) throws ApiException {
        okhttp3.Call localVarCall = getSignatureRequestValidateBeforeCall(requestId, signeeId, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a signature request by its identifier. (asynchronously)
     * Use this operation to retrieve a signature request by its identifier.&lt;br&gt; When accessed with no authentication, only public attributes of the signature request are returned. 
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signee is returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestAsync(String requestId, String signeeId, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSignatureRequestValidateBeforeCall(requestId, signeeId, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchSignatureRequests
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchSignatureRequestsCall(Integer page, Integer size, String direction, String sort, String name, String hashToSign, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequests";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (hashToSign != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hashToSign", hashToSign));
        }

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchSignatureRequestsValidateBeforeCall(Integer page, Integer size, String direction, String sort, String name, String hashToSign, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = searchSignatureRequestsCall(page, size, direction, sort, name, hashToSign, _callback);
        return localVarCall;

    }

    /**
     * Search for signature requests.
     * Use this operation to retrieve all signature requests having a given &#x60;name&#x60; and/or &#x60;hashToSign&#x60; property.&lt;br&gt; Only requests belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @return SignatureRequests
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequests searchSignatureRequests(Integer page, Integer size, String direction, String sort, String name, String hashToSign) throws ApiException {
        ApiResponse<SignatureRequests> localVarResp = searchSignatureRequestsWithHttpInfo(page, size, direction, sort, name, hashToSign);
        return localVarResp.getData();
    }

    /**
     * Search for signature requests.
     * Use this operation to retrieve all signature requests having a given &#x60;name&#x60; and/or &#x60;hashToSign&#x60; property.&lt;br&gt; Only requests belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @return ApiResponse&lt;SignatureRequests&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequests> searchSignatureRequestsWithHttpInfo(Integer page, Integer size, String direction, String sort, String name, String hashToSign) throws ApiException {
        okhttp3.Call localVarCall = searchSignatureRequestsValidateBeforeCall(page, size, direction, sort, name, hashToSign, null);
        Type localVarReturnType = new TypeToken<SignatureRequests>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for signature requests. (asynchronously)
     * Use this operation to retrieve all signature requests having a given &#x60;name&#x60; and/or &#x60;hashToSign&#x60; property.&lt;br&gt; Only requests belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;id&#x60;, &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchSignatureRequestsAsync(Integer page, Integer size, String direction, String sort, String name, String hashToSign, final ApiCallback<SignatureRequests> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchSignatureRequestsValidateBeforeCall(page, size, direction, sort, name, hashToSign, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequests>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for sendSignatureRequestOTP
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signee. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (signee identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, or the signee does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request or signee not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sendSignatureRequestOTPCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/otp/{signeeId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()))
            .replaceAll("\\{" + "signeeId" + "\\}", localVarApiClient.escapeString(signeeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sendSignatureRequestOTPValidateBeforeCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling sendSignatureRequestOTP(Async)");
        }
        
        // verify the required parameter 'signeeId' is set
        if (signeeId == null) {
            throw new ApiException("Missing the required parameter 'signeeId' when calling sendSignatureRequestOTP(Async)");
        }
        

        okhttp3.Call localVarCall = sendSignatureRequestOTPCall(requestId, signeeId, _callback);
        return localVarCall;

    }

    /**
     * Generate and send an OTP to a signee of a signature request.
     * Use this operation to generate and send a new OTP (One Time Password) by SMS to a signee of a signature request.&lt;br&gt; This OTP can be used to sign during a maximum period of 10 mn. 
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signee. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (signee identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, or the signee does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request or signee not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public void sendSignatureRequestOTP(String requestId, String signeeId) throws ApiException {
        sendSignatureRequestOTPWithHttpInfo(requestId, signeeId);
    }

    /**
     * Generate and send an OTP to a signee of a signature request.
     * Use this operation to generate and send a new OTP (One Time Password) by SMS to a signee of a signature request.&lt;br&gt; This OTP can be used to sign during a maximum period of 10 mn. 
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signee. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (signee identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, or the signee does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request or signee not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> sendSignatureRequestOTPWithHttpInfo(String requestId, String signeeId) throws ApiException {
        okhttp3.Call localVarCall = sendSignatureRequestOTPValidateBeforeCall(requestId, signeeId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Generate and send an OTP to a signee of a signature request. (asynchronously)
     * Use this operation to generate and send a new OTP (One Time Password) by SMS to a signee of a signature request.&lt;br&gt; This OTP can be used to sign during a maximum period of 10 mn. 
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signee wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signee. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (signee identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, or the signee does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request or signee not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sendSignatureRequestOTPAsync(String requestId, String signeeId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = sendSignatureRequestOTPValidateBeforeCall(requestId, signeeId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for signSignatureRequest
     * @param requestId Identifier of the signature request. (required)
     * @param signature Signature to register. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (public key or signee identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signee has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call signSignatureRequestCall(String requestId, SignatureRequestSign signature, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signature;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/sign"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call signSignatureRequestValidateBeforeCall(String requestId, SignatureRequestSign signature, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling signSignatureRequest(Async)");
        }
        
        // verify the required parameter 'signature' is set
        if (signature == null) {
            throw new ApiException("Missing the required parameter 'signature' when calling signSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = signSignatureRequestCall(requestId, signature, _callback);
        return localVarCall;

    }

    /**
     * Sign a signature request.
     * Use this operation to register a signature in a signature request.&lt;br&gt; The signature is automatically anchored (on behalf of the owner of the signature request).&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to register a signature. 
     * @param requestId Identifier of the signature request. (required)
     * @param signature Signature to register. (required)
     * @return SignatureRequestSignResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (public key or signee identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signee has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequestSignResult signSignatureRequest(String requestId, SignatureRequestSign signature) throws ApiException {
        ApiResponse<SignatureRequestSignResult> localVarResp = signSignatureRequestWithHttpInfo(requestId, signature);
        return localVarResp.getData();
    }

    /**
     * Sign a signature request.
     * Use this operation to register a signature in a signature request.&lt;br&gt; The signature is automatically anchored (on behalf of the owner of the signature request).&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to register a signature. 
     * @param requestId Identifier of the signature request. (required)
     * @param signature Signature to register. (required)
     * @return ApiResponse&lt;SignatureRequestSignResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (public key or signee identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signee has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequestSignResult> signSignatureRequestWithHttpInfo(String requestId, SignatureRequestSign signature) throws ApiException {
        okhttp3.Call localVarCall = signSignatureRequestValidateBeforeCall(requestId, signature, null);
        Type localVarReturnType = new TypeToken<SignatureRequestSignResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Sign a signature request. (asynchronously)
     * Use this operation to register a signature in a signature request.&lt;br&gt; The signature is automatically anchored (on behalf of the owner of the signature request).&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to register a signature. 
     * @param requestId Identifier of the signature request. (required)
     * @param signature Signature to register. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signee is not an authorized signee (public key or signee identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is suspended, the deadline has been reached, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signee has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call signSignatureRequestAsync(String requestId, SignatureRequestSign signature, final ApiCallback<SignatureRequestSignResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = signSignatureRequestValidateBeforeCall(requestId, signature, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequestSignResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSignatureRequest
     * @param requestId Identifier of signature request to update. (required)
     * @param request SignatureRequest object to update. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSignatureRequestCall(String requestId, SignatureRequest request, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = request;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSignatureRequestValidateBeforeCall(String requestId, SignatureRequest request, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling updateSignatureRequest(Async)");
        }
        
        // verify the required parameter 'request' is set
        if (request == null) {
            throw new ApiException("Missing the required parameter 'request' when calling updateSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = updateSignatureRequestCall(requestId, request, _callback);
        return localVarCall;

    }

    /**
     * Update a signature request.
     * Use this operation to update a signature request.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;suspended&#x60;, &#x60;deadline&#x60;, &#x60;maxSignatures&#x60; and &#x60;authorizedSignees&#x60; can be modified.&lt;br&gt; 
     * @param requestId Identifier of signature request to update. (required)
     * @param request SignatureRequest object to update. (required)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest updateSignatureRequest(String requestId, SignatureRequest request) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = updateSignatureRequestWithHttpInfo(requestId, request);
        return localVarResp.getData();
    }

    /**
     * Update a signature request.
     * Use this operation to update a signature request.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;suspended&#x60;, &#x60;deadline&#x60;, &#x60;maxSignatures&#x60; and &#x60;authorizedSignees&#x60; can be modified.&lt;br&gt; 
     * @param requestId Identifier of signature request to update. (required)
     * @param request SignatureRequest object to update. (required)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> updateSignatureRequestWithHttpInfo(String requestId, SignatureRequest request) throws ApiException {
        okhttp3.Call localVarCall = updateSignatureRequestValidateBeforeCall(requestId, request, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a signature request. (asynchronously)
     * Use this operation to update a signature request.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;suspended&#x60;, &#x60;deadline&#x60;, &#x60;maxSignatures&#x60; and &#x60;authorizedSignees&#x60; can be modified.&lt;br&gt; 
     * @param requestId Identifier of signature request to update. (required)
     * @param request SignatureRequest object to update. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid signature request object. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSignatureRequestAsync(String requestId, SignatureRequest request, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSignatureRequestValidateBeforeCall(requestId, request, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
