/*
 * Woleet API
 * Welcome to **Woleet API reference documentation**.<br> It is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation. 
 *
 * The version of the OpenAPI document: 1.12.0
 * Contact: contact@woleet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.woleet.api.client;

import io.woleet.api.ApiCallback;
import io.woleet.api.ApiClient;
import io.woleet.api.ApiException;
import io.woleet.api.ApiResponse;
import io.woleet.api.Configuration;
import io.woleet.api.Pair;
import io.woleet.api.ProgressRequestBody;
import io.woleet.api.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import io.woleet.api.client.model.SignatureRequest;
import io.woleet.api.client.model.SignatureRequestDelegate;
import io.woleet.api.client.model.SignatureRequestEvent;
import io.woleet.api.client.model.SignatureRequestFeedback;
import io.woleet.api.client.model.SignatureRequestIds;
import io.woleet.api.client.model.SignatureRequestProofBundle;
import io.woleet.api.client.model.SignatureRequestSign;
import io.woleet.api.client.model.SignatureRequestSignResult;
import io.woleet.api.client.model.SignatureRequests;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SignatureRequestApi {
    private ApiClient localVarApiClient;

    public SignatureRequestApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SignatureRequestApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for createSignatureRequest
     * @param signatureRequest SignatureRequest object to create. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the responsebody as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSignatureRequestCall(SignatureRequest signatureRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequest;

        // create path and map variables
        String localVarPath = "/signatureRequest";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSignatureRequestValidateBeforeCall(SignatureRequest signatureRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'signatureRequest' is set
        if (signatureRequest == null) {
            throw new ApiException("Missing the required parameter 'signatureRequest' when calling createSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = createSignatureRequestCall(signatureRequest, _callback);
        return localVarCall;

    }

    /**
     * Create a new signature request.
     * Use this operation to create a new signature request.&lt;br&gt; The properties &#x60;id&#x60;, &#x60;created&#x60; and &#x60;lastModified&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned request.&lt;br&gt; Only the properties &#x60;name&#x60; and &#x60;hashToSign&#x60; are required: the &#x60;hashToSign&#x60; property must be the SHA256 hash of the file to sign.&lt;br&gt; Be sure to have at least 1 signature request credit and enough signature and anchoring credits on your account to fulfill the signature request (each registered signature costs you 1 signature and 1 anchoring credit).&lt;br&gt; 
     * @param signatureRequest SignatureRequest object to create. (required)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the responsebody as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest createSignatureRequest(SignatureRequest signatureRequest) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = createSignatureRequestWithHttpInfo(signatureRequest);
        return localVarResp.getData();
    }

    /**
     * Create a new signature request.
     * Use this operation to create a new signature request.&lt;br&gt; The properties &#x60;id&#x60;, &#x60;created&#x60; and &#x60;lastModified&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned request.&lt;br&gt; Only the properties &#x60;name&#x60; and &#x60;hashToSign&#x60; are required: the &#x60;hashToSign&#x60; property must be the SHA256 hash of the file to sign.&lt;br&gt; Be sure to have at least 1 signature request credit and enough signature and anchoring credits on your account to fulfill the signature request (each registered signature costs you 1 signature and 1 anchoring credit).&lt;br&gt; 
     * @param signatureRequest SignatureRequest object to create. (required)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the responsebody as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> createSignatureRequestWithHttpInfo(SignatureRequest signatureRequest) throws ApiException {
        okhttp3.Call localVarCall = createSignatureRequestValidateBeforeCall(signatureRequest, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a new signature request. (asynchronously)
     * Use this operation to create a new signature request.&lt;br&gt; The properties &#x60;id&#x60;, &#x60;created&#x60; and &#x60;lastModified&#x60; are read-only and so must not be provided: they are managed by the platform and added to the returned request.&lt;br&gt; Only the properties &#x60;name&#x60; and &#x60;hashToSign&#x60; are required: the &#x60;hashToSign&#x60; property must be the SHA256 hash of the file to sign.&lt;br&gt; Be sure to have at least 1 signature request credit and enough signature and anchoring credits on your account to fulfill the signature request (each registered signature costs you 1 signature and 1 anchoring credit).&lt;br&gt; 
     * @param signatureRequest SignatureRequest object to create. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The created signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the responsebody as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSignatureRequestAsync(SignatureRequest signatureRequest, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = createSignatureRequestValidateBeforeCall(signatureRequest, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for delegateSignSignatureRequest
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestDelegate Authentication information about the signer. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully delegated. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call delegateSignSignatureRequestCall(String requestId, SignatureRequestDelegate signatureRequestDelegate, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequestDelegate;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/delegate"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call delegateSignSignatureRequestValidateBeforeCall(String requestId, SignatureRequestDelegate signatureRequestDelegate, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling delegateSignSignatureRequest(Async)");
        }
        
        // verify the required parameter 'signatureRequestDelegate' is set
        if (signatureRequestDelegate == null) {
            throw new ApiException("Missing the required parameter 'signatureRequestDelegate' when calling delegateSignSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = delegateSignSignatureRequestCall(requestId, signatureRequestDelegate, _callback);
        return localVarCall;

    }

    /**
     * Sign a signature request by delegating the signature.
     * A signer can use this operation to sign a signature request by delegating the signature to the platform.&lt;br&gt; When using this signature mode, the signature key of the signer is controled by the platform, which acts as a trusted third party.&lt;br&gt; The signature is automatically anchored on behalf of the owner of the signature request.&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to delegate a signature (authentication of the signer rely on the knowledge of his secret identifier and OTP). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestDelegate Authentication information about the signer. (required)
     * @return SignatureRequestSignResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully delegated. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequestSignResult delegateSignSignatureRequest(String requestId, SignatureRequestDelegate signatureRequestDelegate) throws ApiException {
        ApiResponse<SignatureRequestSignResult> localVarResp = delegateSignSignatureRequestWithHttpInfo(requestId, signatureRequestDelegate);
        return localVarResp.getData();
    }

    /**
     * Sign a signature request by delegating the signature.
     * A signer can use this operation to sign a signature request by delegating the signature to the platform.&lt;br&gt; When using this signature mode, the signature key of the signer is controled by the platform, which acts as a trusted third party.&lt;br&gt; The signature is automatically anchored on behalf of the owner of the signature request.&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to delegate a signature (authentication of the signer rely on the knowledge of his secret identifier and OTP). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestDelegate Authentication information about the signer. (required)
     * @return ApiResponse&lt;SignatureRequestSignResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully delegated. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequestSignResult> delegateSignSignatureRequestWithHttpInfo(String requestId, SignatureRequestDelegate signatureRequestDelegate) throws ApiException {
        okhttp3.Call localVarCall = delegateSignSignatureRequestValidateBeforeCall(requestId, signatureRequestDelegate, null);
        Type localVarReturnType = new TypeToken<SignatureRequestSignResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Sign a signature request by delegating the signature. (asynchronously)
     * A signer can use this operation to sign a signature request by delegating the signature to the platform.&lt;br&gt; When using this signature mode, the signature key of the signer is controled by the platform, which acts as a trusted third party.&lt;br&gt; The signature is automatically anchored on behalf of the owner of the signature request.&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to delegate a signature (authentication of the signer rely on the knowledge of his secret identifier and OTP). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestDelegate Authentication information about the signer. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully delegated. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call delegateSignSignatureRequestAsync(String requestId, SignatureRequestDelegate signatureRequestDelegate, final ApiCallback<SignatureRequestSignResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = delegateSignSignatureRequestValidateBeforeCall(requestId, signatureRequestDelegate, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequestSignResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteSignatureRequest
     * @param requestId Identifier of the signature request to delete. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSignatureRequestCall(String requestId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSignatureRequestValidateBeforeCall(String requestId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling deleteSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = deleteSignatureRequestCall(requestId, _callback);
        return localVarCall;

    }

    /**
     * Delete a signature request.
     * Use this operation to delete a signature request.&lt;br&gt; **WARNING: You should never delete a signature request, otherwise you will no longer be able to download its proof bundle or Signature Attestation document.&lt;br&gt; Use this for test purpose only.** 
     * @param requestId Identifier of the signature request to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteSignatureRequest(String requestId) throws ApiException {
        deleteSignatureRequestWithHttpInfo(requestId);
    }

    /**
     * Delete a signature request.
     * Use this operation to delete a signature request.&lt;br&gt; **WARNING: You should never delete a signature request, otherwise you will no longer be able to download its proof bundle or Signature Attestation document.&lt;br&gt; Use this for test purpose only.** 
     * @param requestId Identifier of the signature request to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteSignatureRequestWithHttpInfo(String requestId) throws ApiException {
        okhttp3.Call localVarCall = deleteSignatureRequestValidateBeforeCall(requestId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a signature request. (asynchronously)
     * Use this operation to delete a signature request.&lt;br&gt; **WARNING: You should never delete a signature request, otherwise you will no longer be able to download its proof bundle or Signature Attestation document.&lt;br&gt; Use this for test purpose only.** 
     * @param requestId Identifier of the signature request to delete. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request is deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSignatureRequestAsync(String requestId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSignatureRequestValidateBeforeCall(requestId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for downloadSignatureRequestFile
     * @param requestId Identifier of the signature request. (required)
     * @param amended &#x60;true&#x60; if the amended version of the document is to be returned.  (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The file to sign. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call downloadSignatureRequestFileCall(String requestId, Boolean amended, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/file"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (amended != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("amended", amended));
        }

        final String[] localVarAccepts = {
            "application/octet-stream"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call downloadSignatureRequestFileValidateBeforeCall(String requestId, Boolean amended, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling downloadSignatureRequestFile(Async)");
        }
        

        okhttp3.Call localVarCall = downloadSignatureRequestFileCall(requestId, amended, _callback);
        return localVarCall;

    }

    /**
     * Download the file to sign.
     * Use this operation to download the file to be signed for a signature request.&lt;br&gt; If the signature request is CLOSED or COMPLETED and the signed file is a PDF document that was uploaded to Woleet, this operation can also be used to download the amended document: this document is basically the signed file concatenated with the Signature Attestation document. The amended document contains the proof bundle as attachement, and is certified by Woleet.&lt;br&gt; The name of the file is included in the &#x60;Content-Disposition&#x60; header (see https://www.ietf.org/rfc/rfc6266.txt).&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to download the file to be signed for a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @param amended &#x60;true&#x60; if the amended version of the document is to be returned.  (optional, default to false)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The file to sign. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public File downloadSignatureRequestFile(String requestId, Boolean amended) throws ApiException {
        ApiResponse<File> localVarResp = downloadSignatureRequestFileWithHttpInfo(requestId, amended);
        return localVarResp.getData();
    }

    /**
     * Download the file to sign.
     * Use this operation to download the file to be signed for a signature request.&lt;br&gt; If the signature request is CLOSED or COMPLETED and the signed file is a PDF document that was uploaded to Woleet, this operation can also be used to download the amended document: this document is basically the signed file concatenated with the Signature Attestation document. The amended document contains the proof bundle as attachement, and is certified by Woleet.&lt;br&gt; The name of the file is included in the &#x60;Content-Disposition&#x60; header (see https://www.ietf.org/rfc/rfc6266.txt).&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to download the file to be signed for a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @param amended &#x60;true&#x60; if the amended version of the document is to be returned.  (optional, default to false)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The file to sign. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> downloadSignatureRequestFileWithHttpInfo(String requestId, Boolean amended) throws ApiException {
        okhttp3.Call localVarCall = downloadSignatureRequestFileValidateBeforeCall(requestId, amended, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Download the file to sign. (asynchronously)
     * Use this operation to download the file to be signed for a signature request.&lt;br&gt; If the signature request is CLOSED or COMPLETED and the signed file is a PDF document that was uploaded to Woleet, this operation can also be used to download the amended document: this document is basically the signed file concatenated with the Signature Attestation document. The amended document contains the proof bundle as attachement, and is certified by Woleet.&lt;br&gt; The name of the file is included in the &#x60;Content-Disposition&#x60; header (see https://www.ietf.org/rfc/rfc6266.txt).&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to download the file to be signed for a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @param amended &#x60;true&#x60; if the amended version of the document is to be returned.  (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The file to sign. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call downloadSignatureRequestFileAsync(String requestId, Boolean amended, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = downloadSignatureRequestFileValidateBeforeCall(requestId, amended, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSignatureRequest
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signer is guaranteed to be returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (signeeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("signeeId", signeeId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSignatureRequestValidateBeforeCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling getSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = getSignatureRequestCall(requestId, signeeId, _callback);
        return localVarCall;

    }

    /**
     * Get a signature request by its identifier.
     * Use this operation to retrieve a signature request by its identifier.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve a signature request (but its identifier needs to be known).&lt;br&gt; Nevertheless, if the caller is authenticated as the owner of the signature request, additional information is returned. 
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signer is guaranteed to be returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (optional)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest getSignatureRequest(String requestId, String signeeId) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = getSignatureRequestWithHttpInfo(requestId, signeeId);
        return localVarResp.getData();
    }

    /**
     * Get a signature request by its identifier.
     * Use this operation to retrieve a signature request by its identifier.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve a signature request (but its identifier needs to be known).&lt;br&gt; Nevertheless, if the caller is authenticated as the owner of the signature request, additional information is returned. 
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signer is guaranteed to be returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (optional)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> getSignatureRequestWithHttpInfo(String requestId, String signeeId) throws ApiException {
        okhttp3.Call localVarCall = getSignatureRequestValidateBeforeCall(requestId, signeeId, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a signature request by its identifier. (asynchronously)
     * Use this operation to retrieve a signature request by its identifier.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve a signature request (but its identifier needs to be known).&lt;br&gt; Nevertheless, if the caller is authenticated as the owner of the signature request, additional information is returned. 
     * @param requestId Identifier of the signature request to retrieve. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve the signature request.&lt;br&gt; If set, information related to this signer is guaranteed to be returned in &#x60;authorizedSignees[0]&#x60;.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The signature request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestAsync(String requestId, String signeeId, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSignatureRequestValidateBeforeCall(requestId, signeeId, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSignatureRequestAttestation
     * @param requestId Identifier of the signature request. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Signature Attestation document. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Signature Attestation document not yet available. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestAttestationCall(String requestId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/attestation"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSignatureRequestAttestationValidateBeforeCall(String requestId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling getSignatureRequestAttestation(Async)");
        }
        

        okhttp3.Call localVarCall = getSignatureRequestAttestationCall(requestId, _callback);
        return localVarCall;

    }

    /**
     * Download the Signature Attestation document of a signature request.
     * Use this operation to retrieve the Signature Attestation document of a signature request.&lt;br&gt; This PDF file summarizes the signature request and includes the proof bundle as an attachement.&lt;br&gt; The proof bundle is a JSON file containing all the pieces of evidence: - the audit trail - the proof receipt of the signature of the audit trail by the platform - the proof receipts of the signature of the file by the signers  Consequently, the signature attestation is only available once all the following conditions are met: - the signature request is COMPLETED (by the platform) or CLOSED (by the requester) - all the proof receipts are available (ie. all signatures have been anchored) - the audit trail is generated and signed by the platform and its proof receipt is available (ie. its signature has been anchored)  Once these conditions are met, the platform sets the &#x60;proofBundleComplete&#x60; property to &#x60;true&#x60;.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve the signature attestation of a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Signature Attestation document. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Signature Attestation document not yet available. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public File getSignatureRequestAttestation(String requestId) throws ApiException {
        ApiResponse<File> localVarResp = getSignatureRequestAttestationWithHttpInfo(requestId);
        return localVarResp.getData();
    }

    /**
     * Download the Signature Attestation document of a signature request.
     * Use this operation to retrieve the Signature Attestation document of a signature request.&lt;br&gt; This PDF file summarizes the signature request and includes the proof bundle as an attachement.&lt;br&gt; The proof bundle is a JSON file containing all the pieces of evidence: - the audit trail - the proof receipt of the signature of the audit trail by the platform - the proof receipts of the signature of the file by the signers  Consequently, the signature attestation is only available once all the following conditions are met: - the signature request is COMPLETED (by the platform) or CLOSED (by the requester) - all the proof receipts are available (ie. all signatures have been anchored) - the audit trail is generated and signed by the platform and its proof receipt is available (ie. its signature has been anchored)  Once these conditions are met, the platform sets the &#x60;proofBundleComplete&#x60; property to &#x60;true&#x60;.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve the signature attestation of a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Signature Attestation document. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Signature Attestation document not yet available. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getSignatureRequestAttestationWithHttpInfo(String requestId) throws ApiException {
        okhttp3.Call localVarCall = getSignatureRequestAttestationValidateBeforeCall(requestId, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Download the Signature Attestation document of a signature request. (asynchronously)
     * Use this operation to retrieve the Signature Attestation document of a signature request.&lt;br&gt; This PDF file summarizes the signature request and includes the proof bundle as an attachement.&lt;br&gt; The proof bundle is a JSON file containing all the pieces of evidence: - the audit trail - the proof receipt of the signature of the audit trail by the platform - the proof receipts of the signature of the file by the signers  Consequently, the signature attestation is only available once all the following conditions are met: - the signature request is COMPLETED (by the platform) or CLOSED (by the requester) - all the proof receipts are available (ie. all signatures have been anchored) - the audit trail is generated and signed by the platform and its proof receipt is available (ie. its signature has been anchored)  Once these conditions are met, the platform sets the &#x60;proofBundleComplete&#x60; property to &#x60;true&#x60;.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve the signature attestation of a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Signature Attestation document. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Signature Attestation document not yet available. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestAttestationAsync(String requestId, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSignatureRequestAttestationValidateBeforeCall(requestId, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSignatureRequestProofBundle
     * @param requestId Identifier of the signature request. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The proof bundle of the signature request. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> A partial proof bundle of the signature request (some signature are missing or not all receipts are yet available). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestProofBundleCall(String requestId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/proofbundle"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSignatureRequestProofBundleValidateBeforeCall(String requestId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling getSignatureRequestProofBundle(Async)");
        }
        

        okhttp3.Call localVarCall = getSignatureRequestProofBundleCall(requestId, _callback);
        return localVarCall;

    }

    /**
     * Get the proof bundle of a signature request.
     * Use this operation to retrieve the proof bundle of a signature request.&lt;br&gt; The proof bundle is a JSON file containing all the pieces of evidence: - the audit trail - the proof receipt of the signature of the audit trail by the platform - the proof receipts of the signature of the file by the signers  Consequently, the proof bundle is only available once all the following conditions are met: - the signature request is COMPLETED (by the platform) or CLOSED (by the requester) - all the proof receipts are available (ie. all signatures have been anchored) - the audit trail is generated and signed by the platform and its proof receipt is available (ie. its signature has been anchored)  Once these conditions are met, the platform sets the &#x60;proofBundleComplete&#x60; property to &#x60;true&#x60;.&lt;br&gt; If this endpoint is called before all these conditions are met, it returns only the available proof receipts (with a 202 status).&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve the proof bundle of a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @return SignatureRequestProofBundle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The proof bundle of the signature request. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> A partial proof bundle of the signature request (some signature are missing or not all receipts are yet available). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequestProofBundle getSignatureRequestProofBundle(String requestId) throws ApiException {
        ApiResponse<SignatureRequestProofBundle> localVarResp = getSignatureRequestProofBundleWithHttpInfo(requestId);
        return localVarResp.getData();
    }

    /**
     * Get the proof bundle of a signature request.
     * Use this operation to retrieve the proof bundle of a signature request.&lt;br&gt; The proof bundle is a JSON file containing all the pieces of evidence: - the audit trail - the proof receipt of the signature of the audit trail by the platform - the proof receipts of the signature of the file by the signers  Consequently, the proof bundle is only available once all the following conditions are met: - the signature request is COMPLETED (by the platform) or CLOSED (by the requester) - all the proof receipts are available (ie. all signatures have been anchored) - the audit trail is generated and signed by the platform and its proof receipt is available (ie. its signature has been anchored)  Once these conditions are met, the platform sets the &#x60;proofBundleComplete&#x60; property to &#x60;true&#x60;.&lt;br&gt; If this endpoint is called before all these conditions are met, it returns only the available proof receipts (with a 202 status).&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve the proof bundle of a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @return ApiResponse&lt;SignatureRequestProofBundle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The proof bundle of the signature request. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> A partial proof bundle of the signature request (some signature are missing or not all receipts are yet available). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequestProofBundle> getSignatureRequestProofBundleWithHttpInfo(String requestId) throws ApiException {
        okhttp3.Call localVarCall = getSignatureRequestProofBundleValidateBeforeCall(requestId, null);
        Type localVarReturnType = new TypeToken<SignatureRequestProofBundle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get the proof bundle of a signature request. (asynchronously)
     * Use this operation to retrieve the proof bundle of a signature request.&lt;br&gt; The proof bundle is a JSON file containing all the pieces of evidence: - the audit trail - the proof receipt of the signature of the audit trail by the platform - the proof receipts of the signature of the file by the signers  Consequently, the proof bundle is only available once all the following conditions are met: - the signature request is COMPLETED (by the platform) or CLOSED (by the requester) - all the proof receipts are available (ie. all signatures have been anchored) - the audit trail is generated and signed by the platform and its proof receipt is available (ie. its signature has been anchored)  Once these conditions are met, the platform sets the &#x60;proofBundleComplete&#x60; property to &#x60;true&#x60;.&lt;br&gt; If this endpoint is called before all these conditions are met, it returns only the available proof receipts (with a 202 status).&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve the proof bundle of a signature request (but its identifier needs to be known). 
     * @param requestId Identifier of the signature request. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The proof bundle of the signature request. </td><td>  -  </td></tr>
        <tr><td> 202 </td><td> A partial proof bundle of the signature request (some signature are missing or not all receipts are yet available). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSignatureRequestProofBundleAsync(String requestId, final ApiCallback<SignatureRequestProofBundle> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSignatureRequestProofBundleValidateBeforeCall(requestId, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequestProofBundle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for reportSignatureRequestEvent
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestEvent Event to report. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Event succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call reportSignatureRequestEventCall(String requestId, SignatureRequestEvent signatureRequestEvent, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequestEvent;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/event"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call reportSignatureRequestEventValidateBeforeCall(String requestId, SignatureRequestEvent signatureRequestEvent, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling reportSignatureRequestEvent(Async)");
        }
        
        // verify the required parameter 'signatureRequestEvent' is set
        if (signatureRequestEvent == null) {
            throw new ApiException("Missing the required parameter 'signatureRequestEvent' when calling reportSignatureRequestEvent(Async)");
        }
        

        okhttp3.Call localVarCall = reportSignatureRequestEventCall(requestId, signatureRequestEvent, _callback);
        return localVarCall;

    }

    /**
     * Report an event on a signature request.
     * A signer can use this operation to report an event on a signature request.&lt;br&gt; Events reported are included in the audit trail of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to report an event (authentication of the signer rely on the knowledge of his secret identifier). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestEvent Event to report. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Event succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public void reportSignatureRequestEvent(String requestId, SignatureRequestEvent signatureRequestEvent) throws ApiException {
        reportSignatureRequestEventWithHttpInfo(requestId, signatureRequestEvent);
    }

    /**
     * Report an event on a signature request.
     * A signer can use this operation to report an event on a signature request.&lt;br&gt; Events reported are included in the audit trail of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to report an event (authentication of the signer rely on the knowledge of his secret identifier). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestEvent Event to report. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Event succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> reportSignatureRequestEventWithHttpInfo(String requestId, SignatureRequestEvent signatureRequestEvent) throws ApiException {
        okhttp3.Call localVarCall = reportSignatureRequestEventValidateBeforeCall(requestId, signatureRequestEvent, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Report an event on a signature request. (asynchronously)
     * A signer can use this operation to report an event on a signature request.&lt;br&gt; Events reported are included in the audit trail of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to report an event (authentication of the signer rely on the knowledge of his secret identifier). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestEvent Event to report. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Event succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call reportSignatureRequestEventAsync(String requestId, SignatureRequestEvent signatureRequestEvent, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = reportSignatureRequestEventValidateBeforeCall(requestId, signatureRequestEvent, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for reportSignatureRequestFeedback
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestFeedback Feedback to report. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Feedback succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call reportSignatureRequestFeedbackCall(String requestId, SignatureRequestFeedback signatureRequestFeedback, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequestFeedback;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/feedback"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call reportSignatureRequestFeedbackValidateBeforeCall(String requestId, SignatureRequestFeedback signatureRequestFeedback, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling reportSignatureRequestFeedback(Async)");
        }
        
        // verify the required parameter 'signatureRequestFeedback' is set
        if (signatureRequestFeedback == null) {
            throw new ApiException("Missing the required parameter 'signatureRequestFeedback' when calling reportSignatureRequestFeedback(Async)");
        }
        

        okhttp3.Call localVarCall = reportSignatureRequestFeedbackCall(requestId, signatureRequestFeedback, _callback);
        return localVarCall;

    }

    /**
     * Report a feedback about a signature request.
     * A signer can use this operation to report a feedback to the owner of a signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to report a feedback (authentication of the signer rely on the knowledge of his secret identifier). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestFeedback Feedback to report. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Feedback succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public void reportSignatureRequestFeedback(String requestId, SignatureRequestFeedback signatureRequestFeedback) throws ApiException {
        reportSignatureRequestFeedbackWithHttpInfo(requestId, signatureRequestFeedback);
    }

    /**
     * Report a feedback about a signature request.
     * A signer can use this operation to report a feedback to the owner of a signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to report a feedback (authentication of the signer rely on the knowledge of his secret identifier). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestFeedback Feedback to report. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Feedback succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> reportSignatureRequestFeedbackWithHttpInfo(String requestId, SignatureRequestFeedback signatureRequestFeedback) throws ApiException {
        okhttp3.Call localVarCall = reportSignatureRequestFeedbackValidateBeforeCall(requestId, signatureRequestFeedback, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Report a feedback about a signature request. (asynchronously)
     * A signer can use this operation to report a feedback to the owner of a signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to report a feedback (authentication of the signer rely on the knowledge of his secret identifier). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestFeedback Feedback to report. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Feedback succesfully reported. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call reportSignatureRequestFeedbackAsync(String requestId, SignatureRequestFeedback signatureRequestFeedback, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = reportSignatureRequestFeedbackValidateBeforeCall(requestId, signatureRequestFeedback, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchSignatureRequestIds
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all public signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (required)
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of signature request identifiers per page. (optional, default to 20)
     * @param userId User identifier to use to filter out results: only public signature requests belonging to this user are returned.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of the identifiers of all public signature requests matching all search criteria, plus additional paging information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchSignatureRequestIdsCall(String hashToSign, Integer page, Integer size, String userId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequestIds";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        if (hashToSign != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hashToSign", hashToSign));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchSignatureRequestIdsValidateBeforeCall(String hashToSign, Integer page, Integer size, String userId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'hashToSign' is set
        if (hashToSign == null) {
            throw new ApiException("Missing the required parameter 'hashToSign' when calling searchSignatureRequestIds(Async)");
        }
        

        okhttp3.Call localVarCall = searchSignatureRequestIdsCall(hashToSign, page, size, userId, _callback);
        return localVarCall;

    }

    /**
     * Search for public signature request identifiers.
     * Use this operation to retrieve the identifiers of all public signature requests having a given &#x60;hashToSign&#x60; property.&lt;br&gt; Only public signature request identifiers are returned.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve public signature request identifiers.&lt;br&gt; Paging is supported. 
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all public signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (required)
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of signature request identifiers per page. (optional, default to 20)
     * @param userId User identifier to use to filter out results: only public signature requests belonging to this user are returned.  (optional)
     * @return SignatureRequestIds
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of the identifiers of all public signature requests matching all search criteria, plus additional paging information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequestIds searchSignatureRequestIds(String hashToSign, Integer page, Integer size, String userId) throws ApiException {
        ApiResponse<SignatureRequestIds> localVarResp = searchSignatureRequestIdsWithHttpInfo(hashToSign, page, size, userId);
        return localVarResp.getData();
    }

    /**
     * Search for public signature request identifiers.
     * Use this operation to retrieve the identifiers of all public signature requests having a given &#x60;hashToSign&#x60; property.&lt;br&gt; Only public signature request identifiers are returned.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve public signature request identifiers.&lt;br&gt; Paging is supported. 
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all public signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (required)
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of signature request identifiers per page. (optional, default to 20)
     * @param userId User identifier to use to filter out results: only public signature requests belonging to this user are returned.  (optional)
     * @return ApiResponse&lt;SignatureRequestIds&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of the identifiers of all public signature requests matching all search criteria, plus additional paging information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequestIds> searchSignatureRequestIdsWithHttpInfo(String hashToSign, Integer page, Integer size, String userId) throws ApiException {
        okhttp3.Call localVarCall = searchSignatureRequestIdsValidateBeforeCall(hashToSign, page, size, userId, null);
        Type localVarReturnType = new TypeToken<SignatureRequestIds>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for public signature request identifiers. (asynchronously)
     * Use this operation to retrieve the identifiers of all public signature requests having a given &#x60;hashToSign&#x60; property.&lt;br&gt; Only public signature request identifiers are returned.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to retrieve public signature request identifiers.&lt;br&gt; Paging is supported. 
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all public signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (required)
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of signature request identifiers per page. (optional, default to 20)
     * @param userId User identifier to use to filter out results: only public signature requests belonging to this user are returned.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of the identifiers of all public signature requests matching all search criteria, plus additional paging information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchSignatureRequestIdsAsync(String hashToSign, Integer page, Integer size, String userId, final ApiCallback<SignatureRequestIds> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchSignatureRequestIdsValidateBeforeCall(hashToSign, page, size, userId, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequestIds>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchSignatureRequests
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @param states States to search for: all signature requests whose &#x60;state&#x60; property is part of theses states are returned.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchSignatureRequestsCall(Integer page, Integer size, String direction, String sort, String name, String hashToSign, List<String> states, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequests";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (hashToSign != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hashToSign", hashToSign));
        }

        if (states != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "states", states));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchSignatureRequestsValidateBeforeCall(Integer page, Integer size, String direction, String sort, String name, String hashToSign, List<String> states, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = searchSignatureRequestsCall(page, size, direction, sort, name, hashToSign, states, _callback);
        return localVarCall;

    }

    /**
     * Search for signature requests.
     * Use this operation to retrieve all signature requests having a given &#x60;name&#x60; and/or &#x60;hashToSign&#x60; property.&lt;br&gt; Only requests belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @param states States to search for: all signature requests whose &#x60;state&#x60; property is part of theses states are returned.  (optional)
     * @return SignatureRequests
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequests searchSignatureRequests(Integer page, Integer size, String direction, String sort, String name, String hashToSign, List<String> states) throws ApiException {
        ApiResponse<SignatureRequests> localVarResp = searchSignatureRequestsWithHttpInfo(page, size, direction, sort, name, hashToSign, states);
        return localVarResp.getData();
    }

    /**
     * Search for signature requests.
     * Use this operation to retrieve all signature requests having a given &#x60;name&#x60; and/or &#x60;hashToSign&#x60; property.&lt;br&gt; Only requests belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @param states States to search for: all signature requests whose &#x60;state&#x60; property is part of theses states are returned.  (optional)
     * @return ApiResponse&lt;SignatureRequests&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequests> searchSignatureRequestsWithHttpInfo(Integer page, Integer size, String direction, String sort, String name, String hashToSign, List<String> states) throws ApiException {
        okhttp3.Call localVarCall = searchSignatureRequestsValidateBeforeCall(page, size, direction, sort, name, hashToSign, states, null);
        Type localVarReturnType = new TypeToken<SignatureRequests>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for signature requests. (asynchronously)
     * Use this operation to retrieve all signature requests having a given &#x60;name&#x60; and/or &#x60;hashToSign&#x60; property.&lt;br&gt; Only requests belonging to the authenticated user are returned.&lt;br&gt; Paging and sorting is supported. 
     * @param page Index of the page to retrieve (from 0). (optional, default to 0)
     * @param size Number of anchors per page. (optional, default to 20)
     * @param direction Sorting direction: ASC for ascending DESC for descending.  (optional, default to ASC)
     * @param sort Sorting property: possible values are limited to &#x60;created&#x60; and &#x60;hashToSign&#x60;.  (optional, default to created)
     * @param name &#x60;name&#x60; to search for: all signature requests whose &#x60;name&#x60; property contains this sub-string are returned.&lt;br&gt; **WARNING: Searching by name can timeout on a large signature request set.**  (optional)
     * @param hashToSign &#x60;hashToSign&#x60; to search for: all signature requests whose &#x60;hashToSign&#x60; property is equal are returned.  (optional)
     * @param states States to search for: all signature requests whose &#x60;state&#x60; property is part of theses states are returned.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 504 </td><td> Can be triggered when searching by name if the request takes too long to process. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchSignatureRequestsAsync(Integer page, Integer size, String direction, String sort, String name, String hashToSign, List<String> states, final ApiCallback<SignatureRequests> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchSignatureRequestsValidateBeforeCall(page, size, direction, sort, name, hashToSign, states, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequests>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for sendSignatureRequestOTP
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signer. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or the signer does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sendSignatureRequestOTPCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/otp/{signeeId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()))
            .replaceAll("\\{" + "signeeId" + "\\}", localVarApiClient.escapeString(signeeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sendSignatureRequestOTPValidateBeforeCall(String requestId, String signeeId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling sendSignatureRequestOTP(Async)");
        }
        
        // verify the required parameter 'signeeId' is set
        if (signeeId == null) {
            throw new ApiException("Missing the required parameter 'signeeId' when calling sendSignatureRequestOTP(Async)");
        }
        

        okhttp3.Call localVarCall = sendSignatureRequestOTPCall(requestId, signeeId, _callback);
        return localVarCall;

    }

    /**
     * Generate and send an OTP to a signer of a signature request.
     * Use this operation to generate and send a new OTP (One Time Password) by SMS to a signer of a signature request.&lt;br&gt; This OTP can be used to sign during a maximum period of 10 mn. 
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signer. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or the signer does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public void sendSignatureRequestOTP(String requestId, String signeeId) throws ApiException {
        sendSignatureRequestOTPWithHttpInfo(requestId, signeeId);
    }

    /**
     * Generate and send an OTP to a signer of a signature request.
     * Use this operation to generate and send a new OTP (One Time Password) by SMS to a signer of a signature request.&lt;br&gt; This OTP can be used to sign during a maximum period of 10 mn. 
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signer. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or the signer does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> sendSignatureRequestOTPWithHttpInfo(String requestId, String signeeId) throws ApiException {
        okhttp3.Call localVarCall = sendSignatureRequestOTPValidateBeforeCall(requestId, signeeId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Generate and send an OTP to a signer of a signature request. (asynchronously)
     * Use this operation to generate and send a new OTP (One Time Password) by SMS to a signer of a signature request.&lt;br&gt; This OTP can be used to sign during a maximum period of 10 mn. 
     * @param requestId Identifier of the signature request. (required)
     * @param signeeId Secret identifier of the signer wanting to retrieve his OTP.&lt;br&gt; **This secret identifier is generated by the platform and provided by email to the signer only. It allows the platform to authenticate the signer and verify his email address.**  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OTP succesfully generated and sent by SMS to the signer. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (secret signer identifier not found). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or the signer does not require an OTP. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required between two OTP generation. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sendSignatureRequestOTPAsync(String requestId, String signeeId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = sendSignatureRequestOTPValidateBeforeCall(requestId, signeeId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for sendSignatureRequestReminder
     * @param requestId Identifier of the signature request. (required)
     * @param requestBody The list of emails of the authorized signers who will receive the reminder email.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reminder email succesfully sent to the signers. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or at least one of the signers already signed. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 hours is required between two reminder emails. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sendSignatureRequestReminderCall(String requestId, List<String> requestBody, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/remind"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sendSignatureRequestReminderValidateBeforeCall(String requestId, List<String> requestBody, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling sendSignatureRequestReminder(Async)");
        }
        
        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling sendSignatureRequestReminder(Async)");
        }
        

        okhttp3.Call localVarCall = sendSignatureRequestReminderCall(requestId, requestBody, _callback);
        return localVarCall;

    }

    /**
     * Send a reminder email to a set of signers of a signature request.
     * Use this operation to send a reminder email to a set of signers of a signature request.&lt;br&gt; This email reminds them that they have a document to sign. 
     * @param requestId Identifier of the signature request. (required)
     * @param requestBody The list of emails of the authorized signers who will receive the reminder email.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reminder email succesfully sent to the signers. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or at least one of the signers already signed. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 hours is required between two reminder emails. </td><td>  -  </td></tr>
     </table>
     */
    public void sendSignatureRequestReminder(String requestId, List<String> requestBody) throws ApiException {
        sendSignatureRequestReminderWithHttpInfo(requestId, requestBody);
    }

    /**
     * Send a reminder email to a set of signers of a signature request.
     * Use this operation to send a reminder email to a set of signers of a signature request.&lt;br&gt; This email reminds them that they have a document to sign. 
     * @param requestId Identifier of the signature request. (required)
     * @param requestBody The list of emails of the authorized signers who will receive the reminder email.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reminder email succesfully sent to the signers. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or at least one of the signers already signed. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 hours is required between two reminder emails. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> sendSignatureRequestReminderWithHttpInfo(String requestId, List<String> requestBody) throws ApiException {
        okhttp3.Call localVarCall = sendSignatureRequestReminderValidateBeforeCall(requestId, requestBody, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Send a reminder email to a set of signers of a signature request. (asynchronously)
     * Use this operation to send a reminder email to a set of signers of a signature request.&lt;br&gt; This email reminds them that they have a document to sign. 
     * @param requestId Identifier of the signature request. (required)
     * @param requestBody The list of emails of the authorized signers who will receive the reminder email.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reminder email succesfully sent to the signers. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, or at least one of the signers already signed. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 hours is required between two reminder emails. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sendSignatureRequestReminderAsync(String requestId, List<String> requestBody, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = sendSignatureRequestReminderValidateBeforeCall(requestId, requestBody, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for signSignatureRequest
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestSign Signature to register. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (public key or secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call signSignatureRequestCall(String requestId, SignatureRequestSign signatureRequestSign, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequestSign;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/sign"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call signSignatureRequestValidateBeforeCall(String requestId, SignatureRequestSign signatureRequestSign, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling signSignatureRequest(Async)");
        }
        
        // verify the required parameter 'signatureRequestSign' is set
        if (signatureRequestSign == null) {
            throw new ApiException("Missing the required parameter 'signatureRequestSign' when calling signSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = signSignatureRequestCall(requestId, signatureRequestSign, _callback);
        return localVarCall;

    }

    /**
     * Sign a signature request by registering a signature.
     * A signer can use this operation to sign a signature request by registering a signature he procuded on his own.&lt;br&gt; The signature is automatically anchored on behalf of the owner of the signature request.&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to register a signature (authentication of the signer rely on the knowledge of his secret identifier and OTP, or on the control of his public key). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestSign Signature to register. (required)
     * @return SignatureRequestSignResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (public key or secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequestSignResult signSignatureRequest(String requestId, SignatureRequestSign signatureRequestSign) throws ApiException {
        ApiResponse<SignatureRequestSignResult> localVarResp = signSignatureRequestWithHttpInfo(requestId, signatureRequestSign);
        return localVarResp.getData();
    }

    /**
     * Sign a signature request by registering a signature.
     * A signer can use this operation to sign a signature request by registering a signature he procuded on his own.&lt;br&gt; The signature is automatically anchored on behalf of the owner of the signature request.&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to register a signature (authentication of the signer rely on the knowledge of his secret identifier and OTP, or on the control of his public key). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestSign Signature to register. (required)
     * @return ApiResponse&lt;SignatureRequestSignResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (public key or secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequestSignResult> signSignatureRequestWithHttpInfo(String requestId, SignatureRequestSign signatureRequestSign) throws ApiException {
        okhttp3.Call localVarCall = signSignatureRequestValidateBeforeCall(requestId, signatureRequestSign, null);
        Type localVarReturnType = new TypeToken<SignatureRequestSignResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Sign a signature request by registering a signature. (asynchronously)
     * A signer can use this operation to sign a signature request by registering a signature he procuded on his own.&lt;br&gt; The signature is automatically anchored on behalf of the owner of the signature request.&lt;br&gt; The signature anchor created is added to the list of signature anchors of the signature request.&lt;br&gt; This is a publicly accessible endpoint: authentication is not required to register a signature (authentication of the signer rely on the knowledge of his secret identifier and OTP, or on the control of his public key). 
     * @param requestId Identifier of the signature request. (required)
     * @param signatureRequestSign Signature to register. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Signature succesfully registered. The signature anchor created is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. The signer is not an authorized signer (public key or secret signer identifier not found, or invalid OTP). </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Insufficient credits. The owner of the signature request runs out of signature or anchoring credit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict. The signer has already signed. </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. A minimum delay of 1 second is required after providing an invalid OTP. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call signSignatureRequestAsync(String requestId, SignatureRequestSign signatureRequestSign, final ApiCallback<SignatureRequestSignResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = signSignatureRequestValidateBeforeCall(requestId, signatureRequestSign, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequestSignResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for transitionSignatureRequest
     * @param requestId Identifier of the signature request. (required)
     * @param body New state of the signature request. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transitioned signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Invalid transition. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call transitionSignatureRequestCall(String requestId, String body, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/transition"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call transitionSignatureRequestValidateBeforeCall(String requestId, String body, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling transitionSignatureRequest(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling transitionSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = transitionSignatureRequestCall(requestId, body, _callback);
        return localVarCall;

    }

    /**
     * Change the state of a signature request.
     * Use this operation to transition a **stateful** signature request to a new state.&lt;br&gt; Possible transitions are: - from DRAFT to PENDING: start the signature request: the platform waits for the activation date (only if set) and transitions the signature request to IN_PROGRESS automatically - from PENDING to DRAFT: suspend the signature request so that it can be updated - from PENDING to CANCELED: cancel the signature request without waiting for the activation date - from IN_PROGRESS to CLOSED: close the signature request before all signatures get colleted - from IN_PROGRESS to CANCELED: cancel the signature request before all signatures get colleted  Note that **stateless** signature requests can only be transitioned to CLOSED or CANCELED, which triggers the generation of the audit trail and its signature by the platform. 
     * @param requestId Identifier of the signature request. (required)
     * @param body New state of the signature request. (required)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transitioned signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Invalid transition. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest transitionSignatureRequest(String requestId, String body) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = transitionSignatureRequestWithHttpInfo(requestId, body);
        return localVarResp.getData();
    }

    /**
     * Change the state of a signature request.
     * Use this operation to transition a **stateful** signature request to a new state.&lt;br&gt; Possible transitions are: - from DRAFT to PENDING: start the signature request: the platform waits for the activation date (only if set) and transitions the signature request to IN_PROGRESS automatically - from PENDING to DRAFT: suspend the signature request so that it can be updated - from PENDING to CANCELED: cancel the signature request without waiting for the activation date - from IN_PROGRESS to CLOSED: close the signature request before all signatures get colleted - from IN_PROGRESS to CANCELED: cancel the signature request before all signatures get colleted  Note that **stateless** signature requests can only be transitioned to CLOSED or CANCELED, which triggers the generation of the audit trail and its signature by the platform. 
     * @param requestId Identifier of the signature request. (required)
     * @param body New state of the signature request. (required)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transitioned signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Invalid transition. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> transitionSignatureRequestWithHttpInfo(String requestId, String body) throws ApiException {
        okhttp3.Call localVarCall = transitionSignatureRequestValidateBeforeCall(requestId, body, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Change the state of a signature request. (asynchronously)
     * Use this operation to transition a **stateful** signature request to a new state.&lt;br&gt; Possible transitions are: - from DRAFT to PENDING: start the signature request: the platform waits for the activation date (only if set) and transitions the signature request to IN_PROGRESS automatically - from PENDING to DRAFT: suspend the signature request so that it can be updated - from PENDING to CANCELED: cancel the signature request without waiting for the activation date - from IN_PROGRESS to CLOSED: close the signature request before all signatures get colleted - from IN_PROGRESS to CANCELED: cancel the signature request before all signatures get colleted  Note that **stateless** signature requests can only be transitioned to CLOSED or CANCELED, which triggers the generation of the audit trail and its signature by the platform. 
     * @param requestId Identifier of the signature request. (required)
     * @param body New state of the signature request. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transitioned signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Invalid transition. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call transitionSignatureRequestAsync(String requestId, String body, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = transitionSignatureRequestValidateBeforeCall(requestId, body, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSignatureRequest
     * @param requestId Identifier of signature request to update. (required)
     * @param signatureRequest SignatureRequest object to update. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request cannot be updated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSignatureRequestCall(String requestId, SignatureRequest signatureRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = signatureRequest;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSignatureRequestValidateBeforeCall(String requestId, SignatureRequest signatureRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling updateSignatureRequest(Async)");
        }
        
        // verify the required parameter 'signatureRequest' is set
        if (signatureRequest == null) {
            throw new ApiException("Missing the required parameter 'signatureRequest' when calling updateSignatureRequest(Async)");
        }
        

        okhttp3.Call localVarCall = updateSignatureRequestCall(requestId, signatureRequest, _callback);
        return localVarCall;

    }

    /**
     * Update a signature request.
     * Use this operation to update a signature request.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;public&#x60;, &#x60;callbackURL&#x60;, &#x60;activation&#x60;, &#x60;deadline&#x60;, &#x60;identityURL&#x60;, &#x60;fileName&#x60;, &#x60;fileURL&#x60;, &#x60;lang&#x60;, &#x60;vars&#x60;, &#x60;maxSignatures&#x60; and &#x60;authorizedSignees&#x60; can be modified.&lt;br&gt; Only **stateless** signature requests or **stateful** signature request in DRAFT state can be updated. 
     * @param requestId Identifier of signature request to update. (required)
     * @param signatureRequest SignatureRequest object to update. (required)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request cannot be updated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest updateSignatureRequest(String requestId, SignatureRequest signatureRequest) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = updateSignatureRequestWithHttpInfo(requestId, signatureRequest);
        return localVarResp.getData();
    }

    /**
     * Update a signature request.
     * Use this operation to update a signature request.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;public&#x60;, &#x60;callbackURL&#x60;, &#x60;activation&#x60;, &#x60;deadline&#x60;, &#x60;identityURL&#x60;, &#x60;fileName&#x60;, &#x60;fileURL&#x60;, &#x60;lang&#x60;, &#x60;vars&#x60;, &#x60;maxSignatures&#x60; and &#x60;authorizedSignees&#x60; can be modified.&lt;br&gt; Only **stateless** signature requests or **stateful** signature request in DRAFT state can be updated. 
     * @param requestId Identifier of signature request to update. (required)
     * @param signatureRequest SignatureRequest object to update. (required)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request cannot be updated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> updateSignatureRequestWithHttpInfo(String requestId, SignatureRequest signatureRequest) throws ApiException {
        okhttp3.Call localVarCall = updateSignatureRequestValidateBeforeCall(requestId, signatureRequest, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a signature request. (asynchronously)
     * Use this operation to update a signature request.&lt;br&gt; Only the properties &#x60;name&#x60;, &#x60;public&#x60;, &#x60;callbackURL&#x60;, &#x60;activation&#x60;, &#x60;deadline&#x60;, &#x60;identityURL&#x60;, &#x60;fileName&#x60;, &#x60;fileURL&#x60;, &#x60;lang&#x60;, &#x60;vars&#x60;, &#x60;maxSignatures&#x60; and &#x60;authorizedSignees&#x60; can be modified.&lt;br&gt; Only **stateless** signature requests or **stateful** signature request in DRAFT state can be updated. 
     * @param requestId Identifier of signature request to update. (required)
     * @param signatureRequest SignatureRequest object to update. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The signature request cannot be updated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No signature request matching the given identifier. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSignatureRequestAsync(String requestId, SignatureRequest signatureRequest, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSignatureRequestValidateBeforeCall(requestId, signatureRequest, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for uploadSignatureRequestFile
     * @param requestId Identifier of the signature request. (required)
     * @param file The file to sign. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File succesfully uploaded and linked to signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The file cannot be uploaded. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uploadSignatureRequestFileCall(String requestId, File file, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatureRequest/{requestId}/file"
            .replaceAll("\\{" + "requestId" + "\\}", localVarApiClient.escapeString(requestId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (file != null) {
            localVarFormParams.put("file", file);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "BasicAuth", "JWTAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadSignatureRequestFileValidateBeforeCall(String requestId, File file, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'requestId' is set
        if (requestId == null) {
            throw new ApiException("Missing the required parameter 'requestId' when calling uploadSignatureRequestFile(Async)");
        }
        
        // verify the required parameter 'file' is set
        if (file == null) {
            throw new ApiException("Missing the required parameter 'file' when calling uploadSignatureRequestFile(Async)");
        }
        

        okhttp3.Call localVarCall = uploadSignatureRequestFileCall(requestId, file, _callback);
        return localVarCall;

    }

    /**
     * Upload the file to sign.
     * Use this operation to upload the file to be signed for a signature request.&lt;br&gt; The SHA256 hash of the uploaded file must be equal to the &#x60;hashToSign&#x60; property of the signature request or the upload fails.&lt;br&gt; Once uploaded, the file is stored and the &#x60;fileURL&#x60; property of the signature request is set, so that it can be used by a signature application to download and present the file to the signers.&lt;br&gt; Only **stateless** signature requests or **stateful** signature request in DRAFT state can be updated. **WARNING: the storage of the file to be signed is provided for convenience only: it is not required, and you should never upload a file if you have any concern about its privacy.** 
     * @param requestId Identifier of the signature request. (required)
     * @param file The file to sign. (required)
     * @return SignatureRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File succesfully uploaded and linked to signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The file cannot be uploaded. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public SignatureRequest uploadSignatureRequestFile(String requestId, File file) throws ApiException {
        ApiResponse<SignatureRequest> localVarResp = uploadSignatureRequestFileWithHttpInfo(requestId, file);
        return localVarResp.getData();
    }

    /**
     * Upload the file to sign.
     * Use this operation to upload the file to be signed for a signature request.&lt;br&gt; The SHA256 hash of the uploaded file must be equal to the &#x60;hashToSign&#x60; property of the signature request or the upload fails.&lt;br&gt; Once uploaded, the file is stored and the &#x60;fileURL&#x60; property of the signature request is set, so that it can be used by a signature application to download and present the file to the signers.&lt;br&gt; Only **stateless** signature requests or **stateful** signature request in DRAFT state can be updated. **WARNING: the storage of the file to be signed is provided for convenience only: it is not required, and you should never upload a file if you have any concern about its privacy.** 
     * @param requestId Identifier of the signature request. (required)
     * @param file The file to sign. (required)
     * @return ApiResponse&lt;SignatureRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File succesfully uploaded and linked to signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The file cannot be uploaded. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SignatureRequest> uploadSignatureRequestFileWithHttpInfo(String requestId, File file) throws ApiException {
        okhttp3.Call localVarCall = uploadSignatureRequestFileValidateBeforeCall(requestId, file, null);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Upload the file to sign. (asynchronously)
     * Use this operation to upload the file to be signed for a signature request.&lt;br&gt; The SHA256 hash of the uploaded file must be equal to the &#x60;hashToSign&#x60; property of the signature request or the upload fails.&lt;br&gt; Once uploaded, the file is stored and the &#x60;fileURL&#x60; property of the signature request is set, so that it can be used by a signature application to download and present the file to the signers.&lt;br&gt; Only **stateless** signature requests or **stateful** signature request in DRAFT state can be updated. **WARNING: the storage of the file to be signed is provided for convenience only: it is not required, and you should never upload a file if you have any concern about its privacy.** 
     * @param requestId Identifier of the signature request. (required)
     * @param file The file to sign. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> File succesfully uploaded and linked to signature request. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request. More details are returned in the response body as a JSON object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. The file cannot be uploaded. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Signature request not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uploadSignatureRequestFileAsync(String requestId, File file, final ApiCallback<SignatureRequest> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadSignatureRequestFileValidateBeforeCall(requestId, file, _callback);
        Type localVarReturnType = new TypeToken<SignatureRequest>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
